/*
Copyright The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by counterfeiter. DO NOT EDIT.
package githubfakes

import (
	"context"
	"io"
	"os"
	"sync"

	githuba "github.com/google/go-github/v72/github"
	"sigs.k8s.io/release-sdk/github"
)

type FakeClient struct {
	AddLabelsStub        func(context.Context, string, string, int, []string) ([]*githuba.Label, *githuba.Response, error)
	addLabelsMutex       sync.RWMutex
	addLabelsArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 int
		arg5 []string
	}
	addLabelsReturns struct {
		result1 []*githuba.Label
		result2 *githuba.Response
		result3 error
	}
	addLabelsReturnsOnCall map[int]struct {
		result1 []*githuba.Label
		result2 *githuba.Response
		result3 error
	}
	CheckRateLimitStub        func(context.Context) (*githuba.RateLimits, *githuba.Response, error)
	checkRateLimitMutex       sync.RWMutex
	checkRateLimitArgsForCall []struct {
		arg1 context.Context
	}
	checkRateLimitReturns struct {
		result1 *githuba.RateLimits
		result2 *githuba.Response
		result3 error
	}
	checkRateLimitReturnsOnCall map[int]struct {
		result1 *githuba.RateLimits
		result2 *githuba.Response
		result3 error
	}
	CreateCommentStub        func(context.Context, string, string, int, string) (*githuba.IssueComment, *githuba.Response, error)
	createCommentMutex       sync.RWMutex
	createCommentArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 int
		arg5 string
	}
	createCommentReturns struct {
		result1 *githuba.IssueComment
		result2 *githuba.Response
		result3 error
	}
	createCommentReturnsOnCall map[int]struct {
		result1 *githuba.IssueComment
		result2 *githuba.Response
		result3 error
	}
	CreateIssueStub        func(context.Context, string, string, *githuba.IssueRequest) (*githuba.Issue, error)
	createIssueMutex       sync.RWMutex
	createIssueArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 *githuba.IssueRequest
	}
	createIssueReturns struct {
		result1 *githuba.Issue
		result2 error
	}
	createIssueReturnsOnCall map[int]struct {
		result1 *githuba.Issue
		result2 error
	}
	CreatePullRequestStub        func(context.Context, string, string, string, string, string, string, bool) (*githuba.PullRequest, error)
	createPullRequestMutex       sync.RWMutex
	createPullRequestArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 string
		arg5 string
		arg6 string
		arg7 string
		arg8 bool
	}
	createPullRequestReturns struct {
		result1 *githuba.PullRequest
		result2 error
	}
	createPullRequestReturnsOnCall map[int]struct {
		result1 *githuba.PullRequest
		result2 error
	}
	DeleteReleaseAssetStub        func(context.Context, string, string, int64) error
	deleteReleaseAssetMutex       sync.RWMutex
	deleteReleaseAssetArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 int64
	}
	deleteReleaseAssetReturns struct {
		result1 error
	}
	deleteReleaseAssetReturnsOnCall map[int]struct {
		result1 error
	}
	DownloadReleaseAssetStub        func(context.Context, string, string, int64) (io.ReadCloser, string, error)
	downloadReleaseAssetMutex       sync.RWMutex
	downloadReleaseAssetArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 int64
	}
	downloadReleaseAssetReturns struct {
		result1 io.ReadCloser
		result2 string
		result3 error
	}
	downloadReleaseAssetReturnsOnCall map[int]struct {
		result1 io.ReadCloser
		result2 string
		result3 error
	}
	GetCommitStub        func(context.Context, string, string, string) (*githuba.Commit, *githuba.Response, error)
	getCommitMutex       sync.RWMutex
	getCommitArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 string
	}
	getCommitReturns struct {
		result1 *githuba.Commit
		result2 *githuba.Response
		result3 error
	}
	getCommitReturnsOnCall map[int]struct {
		result1 *githuba.Commit
		result2 *githuba.Response
		result3 error
	}
	GetIssueStub        func(context.Context, string, string, int) (*githuba.Issue, *githuba.Response, error)
	getIssueMutex       sync.RWMutex
	getIssueArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 int
	}
	getIssueReturns struct {
		result1 *githuba.Issue
		result2 *githuba.Response
		result3 error
	}
	getIssueReturnsOnCall map[int]struct {
		result1 *githuba.Issue
		result2 *githuba.Response
		result3 error
	}
	GetPullRequestStub        func(context.Context, string, string, int) (*githuba.PullRequest, *githuba.Response, error)
	getPullRequestMutex       sync.RWMutex
	getPullRequestArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 int
	}
	getPullRequestReturns struct {
		result1 *githuba.PullRequest
		result2 *githuba.Response
		result3 error
	}
	getPullRequestReturnsOnCall map[int]struct {
		result1 *githuba.PullRequest
		result2 *githuba.Response
		result3 error
	}
	GetReleaseByTagStub        func(context.Context, string, string, string) (*githuba.RepositoryRelease, *githuba.Response, error)
	getReleaseByTagMutex       sync.RWMutex
	getReleaseByTagArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 string
	}
	getReleaseByTagReturns struct {
		result1 *githuba.RepositoryRelease
		result2 *githuba.Response
		result3 error
	}
	getReleaseByTagReturnsOnCall map[int]struct {
		result1 *githuba.RepositoryRelease
		result2 *githuba.Response
		result3 error
	}
	GetRepoCommitStub        func(context.Context, string, string, string) (*githuba.RepositoryCommit, *githuba.Response, error)
	getRepoCommitMutex       sync.RWMutex
	getRepoCommitArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 string
	}
	getRepoCommitReturns struct {
		result1 *githuba.RepositoryCommit
		result2 *githuba.Response
		result3 error
	}
	getRepoCommitReturnsOnCall map[int]struct {
		result1 *githuba.RepositoryCommit
		result2 *githuba.Response
		result3 error
	}
	GetRepositoryStub        func(context.Context, string, string) (*githuba.Repository, *githuba.Response, error)
	getRepositoryMutex       sync.RWMutex
	getRepositoryArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 string
	}
	getRepositoryReturns struct {
		result1 *githuba.Repository
		result2 *githuba.Response
		result3 error
	}
	getRepositoryReturnsOnCall map[int]struct {
		result1 *githuba.Repository
		result2 *githuba.Response
		result3 error
	}
	ListBranchesStub        func(context.Context, string, string, *githuba.BranchListOptions) ([]*githuba.Branch, *githuba.Response, error)
	listBranchesMutex       sync.RWMutex
	listBranchesArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 *githuba.BranchListOptions
	}
	listBranchesReturns struct {
		result1 []*githuba.Branch
		result2 *githuba.Response
		result3 error
	}
	listBranchesReturnsOnCall map[int]struct {
		result1 []*githuba.Branch
		result2 *githuba.Response
		result3 error
	}
	ListCommentsStub        func(context.Context, string, string, int, *githuba.IssueListCommentsOptions) ([]*githuba.IssueComment, *githuba.Response, error)
	listCommentsMutex       sync.RWMutex
	listCommentsArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 int
		arg5 *githuba.IssueListCommentsOptions
	}
	listCommentsReturns struct {
		result1 []*githuba.IssueComment
		result2 *githuba.Response
		result3 error
	}
	listCommentsReturnsOnCall map[int]struct {
		result1 []*githuba.IssueComment
		result2 *githuba.Response
		result3 error
	}
	ListCommitsStub        func(context.Context, string, string, *githuba.CommitsListOptions) ([]*githuba.RepositoryCommit, *githuba.Response, error)
	listCommitsMutex       sync.RWMutex
	listCommitsArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 *githuba.CommitsListOptions
	}
	listCommitsReturns struct {
		result1 []*githuba.RepositoryCommit
		result2 *githuba.Response
		result3 error
	}
	listCommitsReturnsOnCall map[int]struct {
		result1 []*githuba.RepositoryCommit
		result2 *githuba.Response
		result3 error
	}
	ListIssuesStub        func(context.Context, string, string, *githuba.IssueListByRepoOptions) ([]*githuba.Issue, *githuba.Response, error)
	listIssuesMutex       sync.RWMutex
	listIssuesArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 *githuba.IssueListByRepoOptions
	}
	listIssuesReturns struct {
		result1 []*githuba.Issue
		result2 *githuba.Response
		result3 error
	}
	listIssuesReturnsOnCall map[int]struct {
		result1 []*githuba.Issue
		result2 *githuba.Response
		result3 error
	}
	ListMilestonesStub        func(context.Context, string, string, *githuba.MilestoneListOptions) ([]*githuba.Milestone, *githuba.Response, error)
	listMilestonesMutex       sync.RWMutex
	listMilestonesArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 *githuba.MilestoneListOptions
	}
	listMilestonesReturns struct {
		result1 []*githuba.Milestone
		result2 *githuba.Response
		result3 error
	}
	listMilestonesReturnsOnCall map[int]struct {
		result1 []*githuba.Milestone
		result2 *githuba.Response
		result3 error
	}
	ListPullRequestsWithCommitStub        func(context.Context, string, string, string, *githuba.ListOptions) ([]*githuba.PullRequest, *githuba.Response, error)
	listPullRequestsWithCommitMutex       sync.RWMutex
	listPullRequestsWithCommitArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 string
		arg5 *githuba.ListOptions
	}
	listPullRequestsWithCommitReturns struct {
		result1 []*githuba.PullRequest
		result2 *githuba.Response
		result3 error
	}
	listPullRequestsWithCommitReturnsOnCall map[int]struct {
		result1 []*githuba.PullRequest
		result2 *githuba.Response
		result3 error
	}
	ListReleaseAssetsStub        func(context.Context, string, string, int64, *githuba.ListOptions) ([]*githuba.ReleaseAsset, error)
	listReleaseAssetsMutex       sync.RWMutex
	listReleaseAssetsArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 int64
		arg5 *githuba.ListOptions
	}
	listReleaseAssetsReturns struct {
		result1 []*githuba.ReleaseAsset
		result2 error
	}
	listReleaseAssetsReturnsOnCall map[int]struct {
		result1 []*githuba.ReleaseAsset
		result2 error
	}
	ListReleasesStub        func(context.Context, string, string, *githuba.ListOptions) ([]*githuba.RepositoryRelease, *githuba.Response, error)
	listReleasesMutex       sync.RWMutex
	listReleasesArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 *githuba.ListOptions
	}
	listReleasesReturns struct {
		result1 []*githuba.RepositoryRelease
		result2 *githuba.Response
		result3 error
	}
	listReleasesReturnsOnCall map[int]struct {
		result1 []*githuba.RepositoryRelease
		result2 *githuba.Response
		result3 error
	}
	ListTagsStub        func(context.Context, string, string, *githuba.ListOptions) ([]*githuba.RepositoryTag, *githuba.Response, error)
	listTagsMutex       sync.RWMutex
	listTagsArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 *githuba.ListOptions
	}
	listTagsReturns struct {
		result1 []*githuba.RepositoryTag
		result2 *githuba.Response
		result3 error
	}
	listTagsReturnsOnCall map[int]struct {
		result1 []*githuba.RepositoryTag
		result2 *githuba.Response
		result3 error
	}
	RequestPullRequestReviewStub        func(context.Context, string, string, int, []string, []string) (*githuba.PullRequest, error)
	requestPullRequestReviewMutex       sync.RWMutex
	requestPullRequestReviewArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 int
		arg5 []string
		arg6 []string
	}
	requestPullRequestReviewReturns struct {
		result1 *githuba.PullRequest
		result2 error
	}
	requestPullRequestReviewReturnsOnCall map[int]struct {
		result1 *githuba.PullRequest
		result2 error
	}
	UpdateIssueStub        func(context.Context, string, string, int, *githuba.IssueRequest) (*githuba.Issue, *githuba.Response, error)
	updateIssueMutex       sync.RWMutex
	updateIssueArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 int
		arg5 *githuba.IssueRequest
	}
	updateIssueReturns struct {
		result1 *githuba.Issue
		result2 *githuba.Response
		result3 error
	}
	updateIssueReturnsOnCall map[int]struct {
		result1 *githuba.Issue
		result2 *githuba.Response
		result3 error
	}
	UpdateReleasePageStub        func(context.Context, string, string, int64, *githuba.RepositoryRelease) (*githuba.RepositoryRelease, error)
	updateReleasePageMutex       sync.RWMutex
	updateReleasePageArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 int64
		arg5 *githuba.RepositoryRelease
	}
	updateReleasePageReturns struct {
		result1 *githuba.RepositoryRelease
		result2 error
	}
	updateReleasePageReturnsOnCall map[int]struct {
		result1 *githuba.RepositoryRelease
		result2 error
	}
	UploadReleaseAssetStub        func(context.Context, string, string, int64, *githuba.UploadOptions, *os.File) (*githuba.ReleaseAsset, error)
	uploadReleaseAssetMutex       sync.RWMutex
	uploadReleaseAssetArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 int64
		arg5 *githuba.UploadOptions
		arg6 *os.File
	}
	uploadReleaseAssetReturns struct {
		result1 *githuba.ReleaseAsset
		result2 error
	}
	uploadReleaseAssetReturnsOnCall map[int]struct {
		result1 *githuba.ReleaseAsset
		result2 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeClient) AddLabels(arg1 context.Context, arg2 string, arg3 string, arg4 int, arg5 []string) ([]*githuba.Label, *githuba.Response, error) {
	var arg5Copy []string
	if arg5 != nil {
		arg5Copy = make([]string, len(arg5))
		copy(arg5Copy, arg5)
	}
	fake.addLabelsMutex.Lock()
	ret, specificReturn := fake.addLabelsReturnsOnCall[len(fake.addLabelsArgsForCall)]
	fake.addLabelsArgsForCall = append(fake.addLabelsArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 int
		arg5 []string
	}{arg1, arg2, arg3, arg4, arg5Copy})
	stub := fake.AddLabelsStub
	fakeReturns := fake.addLabelsReturns
	fake.recordInvocation("AddLabels", []interface{}{arg1, arg2, arg3, arg4, arg5Copy})
	fake.addLabelsMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4, arg5)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakeClient) AddLabelsCallCount() int {
	fake.addLabelsMutex.RLock()
	defer fake.addLabelsMutex.RUnlock()
	return len(fake.addLabelsArgsForCall)
}

func (fake *FakeClient) AddLabelsCalls(stub func(context.Context, string, string, int, []string) ([]*githuba.Label, *githuba.Response, error)) {
	fake.addLabelsMutex.Lock()
	defer fake.addLabelsMutex.Unlock()
	fake.AddLabelsStub = stub
}

func (fake *FakeClient) AddLabelsArgsForCall(i int) (context.Context, string, string, int, []string) {
	fake.addLabelsMutex.RLock()
	defer fake.addLabelsMutex.RUnlock()
	argsForCall := fake.addLabelsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4, argsForCall.arg5
}

func (fake *FakeClient) AddLabelsReturns(result1 []*githuba.Label, result2 *githuba.Response, result3 error) {
	fake.addLabelsMutex.Lock()
	defer fake.addLabelsMutex.Unlock()
	fake.AddLabelsStub = nil
	fake.addLabelsReturns = struct {
		result1 []*githuba.Label
		result2 *githuba.Response
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeClient) AddLabelsReturnsOnCall(i int, result1 []*githuba.Label, result2 *githuba.Response, result3 error) {
	fake.addLabelsMutex.Lock()
	defer fake.addLabelsMutex.Unlock()
	fake.AddLabelsStub = nil
	if fake.addLabelsReturnsOnCall == nil {
		fake.addLabelsReturnsOnCall = make(map[int]struct {
			result1 []*githuba.Label
			result2 *githuba.Response
			result3 error
		})
	}
	fake.addLabelsReturnsOnCall[i] = struct {
		result1 []*githuba.Label
		result2 *githuba.Response
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeClient) CheckRateLimit(arg1 context.Context) (*githuba.RateLimits, *githuba.Response, error) {
	fake.checkRateLimitMutex.Lock()
	ret, specificReturn := fake.checkRateLimitReturnsOnCall[len(fake.checkRateLimitArgsForCall)]
	fake.checkRateLimitArgsForCall = append(fake.checkRateLimitArgsForCall, struct {
		arg1 context.Context
	}{arg1})
	stub := fake.CheckRateLimitStub
	fakeReturns := fake.checkRateLimitReturns
	fake.recordInvocation("CheckRateLimit", []interface{}{arg1})
	fake.checkRateLimitMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakeClient) CheckRateLimitCallCount() int {
	fake.checkRateLimitMutex.RLock()
	defer fake.checkRateLimitMutex.RUnlock()
	return len(fake.checkRateLimitArgsForCall)
}

func (fake *FakeClient) CheckRateLimitCalls(stub func(context.Context) (*githuba.RateLimits, *githuba.Response, error)) {
	fake.checkRateLimitMutex.Lock()
	defer fake.checkRateLimitMutex.Unlock()
	fake.CheckRateLimitStub = stub
}

func (fake *FakeClient) CheckRateLimitArgsForCall(i int) context.Context {
	fake.checkRateLimitMutex.RLock()
	defer fake.checkRateLimitMutex.RUnlock()
	argsForCall := fake.checkRateLimitArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeClient) CheckRateLimitReturns(result1 *githuba.RateLimits, result2 *githuba.Response, result3 error) {
	fake.checkRateLimitMutex.Lock()
	defer fake.checkRateLimitMutex.Unlock()
	fake.CheckRateLimitStub = nil
	fake.checkRateLimitReturns = struct {
		result1 *githuba.RateLimits
		result2 *githuba.Response
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeClient) CheckRateLimitReturnsOnCall(i int, result1 *githuba.RateLimits, result2 *githuba.Response, result3 error) {
	fake.checkRateLimitMutex.Lock()
	defer fake.checkRateLimitMutex.Unlock()
	fake.CheckRateLimitStub = nil
	if fake.checkRateLimitReturnsOnCall == nil {
		fake.checkRateLimitReturnsOnCall = make(map[int]struct {
			result1 *githuba.RateLimits
			result2 *githuba.Response
			result3 error
		})
	}
	fake.checkRateLimitReturnsOnCall[i] = struct {
		result1 *githuba.RateLimits
		result2 *githuba.Response
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeClient) CreateComment(arg1 context.Context, arg2 string, arg3 string, arg4 int, arg5 string) (*githuba.IssueComment, *githuba.Response, error) {
	fake.createCommentMutex.Lock()
	ret, specificReturn := fake.createCommentReturnsOnCall[len(fake.createCommentArgsForCall)]
	fake.createCommentArgsForCall = append(fake.createCommentArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 int
		arg5 string
	}{arg1, arg2, arg3, arg4, arg5})
	stub := fake.CreateCommentStub
	fakeReturns := fake.createCommentReturns
	fake.recordInvocation("CreateComment", []interface{}{arg1, arg2, arg3, arg4, arg5})
	fake.createCommentMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4, arg5)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakeClient) CreateCommentCallCount() int {
	fake.createCommentMutex.RLock()
	defer fake.createCommentMutex.RUnlock()
	return len(fake.createCommentArgsForCall)
}

func (fake *FakeClient) CreateCommentCalls(stub func(context.Context, string, string, int, string) (*githuba.IssueComment, *githuba.Response, error)) {
	fake.createCommentMutex.Lock()
	defer fake.createCommentMutex.Unlock()
	fake.CreateCommentStub = stub
}

func (fake *FakeClient) CreateCommentArgsForCall(i int) (context.Context, string, string, int, string) {
	fake.createCommentMutex.RLock()
	defer fake.createCommentMutex.RUnlock()
	argsForCall := fake.createCommentArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4, argsForCall.arg5
}

func (fake *FakeClient) CreateCommentReturns(result1 *githuba.IssueComment, result2 *githuba.Response, result3 error) {
	fake.createCommentMutex.Lock()
	defer fake.createCommentMutex.Unlock()
	fake.CreateCommentStub = nil
	fake.createCommentReturns = struct {
		result1 *githuba.IssueComment
		result2 *githuba.Response
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeClient) CreateCommentReturnsOnCall(i int, result1 *githuba.IssueComment, result2 *githuba.Response, result3 error) {
	fake.createCommentMutex.Lock()
	defer fake.createCommentMutex.Unlock()
	fake.CreateCommentStub = nil
	if fake.createCommentReturnsOnCall == nil {
		fake.createCommentReturnsOnCall = make(map[int]struct {
			result1 *githuba.IssueComment
			result2 *githuba.Response
			result3 error
		})
	}
	fake.createCommentReturnsOnCall[i] = struct {
		result1 *githuba.IssueComment
		result2 *githuba.Response
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeClient) CreateIssue(arg1 context.Context, arg2 string, arg3 string, arg4 *githuba.IssueRequest) (*githuba.Issue, error) {
	fake.createIssueMutex.Lock()
	ret, specificReturn := fake.createIssueReturnsOnCall[len(fake.createIssueArgsForCall)]
	fake.createIssueArgsForCall = append(fake.createIssueArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 *githuba.IssueRequest
	}{arg1, arg2, arg3, arg4})
	stub := fake.CreateIssueStub
	fakeReturns := fake.createIssueReturns
	fake.recordInvocation("CreateIssue", []interface{}{arg1, arg2, arg3, arg4})
	fake.createIssueMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeClient) CreateIssueCallCount() int {
	fake.createIssueMutex.RLock()
	defer fake.createIssueMutex.RUnlock()
	return len(fake.createIssueArgsForCall)
}

func (fake *FakeClient) CreateIssueCalls(stub func(context.Context, string, string, *githuba.IssueRequest) (*githuba.Issue, error)) {
	fake.createIssueMutex.Lock()
	defer fake.createIssueMutex.Unlock()
	fake.CreateIssueStub = stub
}

func (fake *FakeClient) CreateIssueArgsForCall(i int) (context.Context, string, string, *githuba.IssueRequest) {
	fake.createIssueMutex.RLock()
	defer fake.createIssueMutex.RUnlock()
	argsForCall := fake.createIssueArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeClient) CreateIssueReturns(result1 *githuba.Issue, result2 error) {
	fake.createIssueMutex.Lock()
	defer fake.createIssueMutex.Unlock()
	fake.CreateIssueStub = nil
	fake.createIssueReturns = struct {
		result1 *githuba.Issue
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) CreateIssueReturnsOnCall(i int, result1 *githuba.Issue, result2 error) {
	fake.createIssueMutex.Lock()
	defer fake.createIssueMutex.Unlock()
	fake.CreateIssueStub = nil
	if fake.createIssueReturnsOnCall == nil {
		fake.createIssueReturnsOnCall = make(map[int]struct {
			result1 *githuba.Issue
			result2 error
		})
	}
	fake.createIssueReturnsOnCall[i] = struct {
		result1 *githuba.Issue
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) CreatePullRequest(arg1 context.Context, arg2 string, arg3 string, arg4 string, arg5 string, arg6 string, arg7 string, arg8 bool) (*githuba.PullRequest, error) {
	fake.createPullRequestMutex.Lock()
	ret, specificReturn := fake.createPullRequestReturnsOnCall[len(fake.createPullRequestArgsForCall)]
	fake.createPullRequestArgsForCall = append(fake.createPullRequestArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 string
		arg5 string
		arg6 string
		arg7 string
		arg8 bool
	}{arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8})
	stub := fake.CreatePullRequestStub
	fakeReturns := fake.createPullRequestReturns
	fake.recordInvocation("CreatePullRequest", []interface{}{arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8})
	fake.createPullRequestMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeClient) CreatePullRequestCallCount() int {
	fake.createPullRequestMutex.RLock()
	defer fake.createPullRequestMutex.RUnlock()
	return len(fake.createPullRequestArgsForCall)
}

func (fake *FakeClient) CreatePullRequestCalls(stub func(context.Context, string, string, string, string, string, string, bool) (*githuba.PullRequest, error)) {
	fake.createPullRequestMutex.Lock()
	defer fake.createPullRequestMutex.Unlock()
	fake.CreatePullRequestStub = stub
}

func (fake *FakeClient) CreatePullRequestArgsForCall(i int) (context.Context, string, string, string, string, string, string, bool) {
	fake.createPullRequestMutex.RLock()
	defer fake.createPullRequestMutex.RUnlock()
	argsForCall := fake.createPullRequestArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4, argsForCall.arg5, argsForCall.arg6, argsForCall.arg7, argsForCall.arg8
}

func (fake *FakeClient) CreatePullRequestReturns(result1 *githuba.PullRequest, result2 error) {
	fake.createPullRequestMutex.Lock()
	defer fake.createPullRequestMutex.Unlock()
	fake.CreatePullRequestStub = nil
	fake.createPullRequestReturns = struct {
		result1 *githuba.PullRequest
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) CreatePullRequestReturnsOnCall(i int, result1 *githuba.PullRequest, result2 error) {
	fake.createPullRequestMutex.Lock()
	defer fake.createPullRequestMutex.Unlock()
	fake.CreatePullRequestStub = nil
	if fake.createPullRequestReturnsOnCall == nil {
		fake.createPullRequestReturnsOnCall = make(map[int]struct {
			result1 *githuba.PullRequest
			result2 error
		})
	}
	fake.createPullRequestReturnsOnCall[i] = struct {
		result1 *githuba.PullRequest
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) DeleteReleaseAsset(arg1 context.Context, arg2 string, arg3 string, arg4 int64) error {
	fake.deleteReleaseAssetMutex.Lock()
	ret, specificReturn := fake.deleteReleaseAssetReturnsOnCall[len(fake.deleteReleaseAssetArgsForCall)]
	fake.deleteReleaseAssetArgsForCall = append(fake.deleteReleaseAssetArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 int64
	}{arg1, arg2, arg3, arg4})
	stub := fake.DeleteReleaseAssetStub
	fakeReturns := fake.deleteReleaseAssetReturns
	fake.recordInvocation("DeleteReleaseAsset", []interface{}{arg1, arg2, arg3, arg4})
	fake.deleteReleaseAssetMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) DeleteReleaseAssetCallCount() int {
	fake.deleteReleaseAssetMutex.RLock()
	defer fake.deleteReleaseAssetMutex.RUnlock()
	return len(fake.deleteReleaseAssetArgsForCall)
}

func (fake *FakeClient) DeleteReleaseAssetCalls(stub func(context.Context, string, string, int64) error) {
	fake.deleteReleaseAssetMutex.Lock()
	defer fake.deleteReleaseAssetMutex.Unlock()
	fake.DeleteReleaseAssetStub = stub
}

func (fake *FakeClient) DeleteReleaseAssetArgsForCall(i int) (context.Context, string, string, int64) {
	fake.deleteReleaseAssetMutex.RLock()
	defer fake.deleteReleaseAssetMutex.RUnlock()
	argsForCall := fake.deleteReleaseAssetArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeClient) DeleteReleaseAssetReturns(result1 error) {
	fake.deleteReleaseAssetMutex.Lock()
	defer fake.deleteReleaseAssetMutex.Unlock()
	fake.DeleteReleaseAssetStub = nil
	fake.deleteReleaseAssetReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) DeleteReleaseAssetReturnsOnCall(i int, result1 error) {
	fake.deleteReleaseAssetMutex.Lock()
	defer fake.deleteReleaseAssetMutex.Unlock()
	fake.DeleteReleaseAssetStub = nil
	if fake.deleteReleaseAssetReturnsOnCall == nil {
		fake.deleteReleaseAssetReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.deleteReleaseAssetReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) DownloadReleaseAsset(arg1 context.Context, arg2 string, arg3 string, arg4 int64) (io.ReadCloser, string, error) {
	fake.downloadReleaseAssetMutex.Lock()
	ret, specificReturn := fake.downloadReleaseAssetReturnsOnCall[len(fake.downloadReleaseAssetArgsForCall)]
	fake.downloadReleaseAssetArgsForCall = append(fake.downloadReleaseAssetArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 int64
	}{arg1, arg2, arg3, arg4})
	stub := fake.DownloadReleaseAssetStub
	fakeReturns := fake.downloadReleaseAssetReturns
	fake.recordInvocation("DownloadReleaseAsset", []interface{}{arg1, arg2, arg3, arg4})
	fake.downloadReleaseAssetMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakeClient) DownloadReleaseAssetCallCount() int {
	fake.downloadReleaseAssetMutex.RLock()
	defer fake.downloadReleaseAssetMutex.RUnlock()
	return len(fake.downloadReleaseAssetArgsForCall)
}

func (fake *FakeClient) DownloadReleaseAssetCalls(stub func(context.Context, string, string, int64) (io.ReadCloser, string, error)) {
	fake.downloadReleaseAssetMutex.Lock()
	defer fake.downloadReleaseAssetMutex.Unlock()
	fake.DownloadReleaseAssetStub = stub
}

func (fake *FakeClient) DownloadReleaseAssetArgsForCall(i int) (context.Context, string, string, int64) {
	fake.downloadReleaseAssetMutex.RLock()
	defer fake.downloadReleaseAssetMutex.RUnlock()
	argsForCall := fake.downloadReleaseAssetArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeClient) DownloadReleaseAssetReturns(result1 io.ReadCloser, result2 string, result3 error) {
	fake.downloadReleaseAssetMutex.Lock()
	defer fake.downloadReleaseAssetMutex.Unlock()
	fake.DownloadReleaseAssetStub = nil
	fake.downloadReleaseAssetReturns = struct {
		result1 io.ReadCloser
		result2 string
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeClient) DownloadReleaseAssetReturnsOnCall(i int, result1 io.ReadCloser, result2 string, result3 error) {
	fake.downloadReleaseAssetMutex.Lock()
	defer fake.downloadReleaseAssetMutex.Unlock()
	fake.DownloadReleaseAssetStub = nil
	if fake.downloadReleaseAssetReturnsOnCall == nil {
		fake.downloadReleaseAssetReturnsOnCall = make(map[int]struct {
			result1 io.ReadCloser
			result2 string
			result3 error
		})
	}
	fake.downloadReleaseAssetReturnsOnCall[i] = struct {
		result1 io.ReadCloser
		result2 string
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeClient) GetCommit(arg1 context.Context, arg2 string, arg3 string, arg4 string) (*githuba.Commit, *githuba.Response, error) {
	fake.getCommitMutex.Lock()
	ret, specificReturn := fake.getCommitReturnsOnCall[len(fake.getCommitArgsForCall)]
	fake.getCommitArgsForCall = append(fake.getCommitArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 string
	}{arg1, arg2, arg3, arg4})
	stub := fake.GetCommitStub
	fakeReturns := fake.getCommitReturns
	fake.recordInvocation("GetCommit", []interface{}{arg1, arg2, arg3, arg4})
	fake.getCommitMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakeClient) GetCommitCallCount() int {
	fake.getCommitMutex.RLock()
	defer fake.getCommitMutex.RUnlock()
	return len(fake.getCommitArgsForCall)
}

func (fake *FakeClient) GetCommitCalls(stub func(context.Context, string, string, string) (*githuba.Commit, *githuba.Response, error)) {
	fake.getCommitMutex.Lock()
	defer fake.getCommitMutex.Unlock()
	fake.GetCommitStub = stub
}

func (fake *FakeClient) GetCommitArgsForCall(i int) (context.Context, string, string, string) {
	fake.getCommitMutex.RLock()
	defer fake.getCommitMutex.RUnlock()
	argsForCall := fake.getCommitArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeClient) GetCommitReturns(result1 *githuba.Commit, result2 *githuba.Response, result3 error) {
	fake.getCommitMutex.Lock()
	defer fake.getCommitMutex.Unlock()
	fake.GetCommitStub = nil
	fake.getCommitReturns = struct {
		result1 *githuba.Commit
		result2 *githuba.Response
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeClient) GetCommitReturnsOnCall(i int, result1 *githuba.Commit, result2 *githuba.Response, result3 error) {
	fake.getCommitMutex.Lock()
	defer fake.getCommitMutex.Unlock()
	fake.GetCommitStub = nil
	if fake.getCommitReturnsOnCall == nil {
		fake.getCommitReturnsOnCall = make(map[int]struct {
			result1 *githuba.Commit
			result2 *githuba.Response
			result3 error
		})
	}
	fake.getCommitReturnsOnCall[i] = struct {
		result1 *githuba.Commit
		result2 *githuba.Response
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeClient) GetIssue(arg1 context.Context, arg2 string, arg3 string, arg4 int) (*githuba.Issue, *githuba.Response, error) {
	fake.getIssueMutex.Lock()
	ret, specificReturn := fake.getIssueReturnsOnCall[len(fake.getIssueArgsForCall)]
	fake.getIssueArgsForCall = append(fake.getIssueArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 int
	}{arg1, arg2, arg3, arg4})
	stub := fake.GetIssueStub
	fakeReturns := fake.getIssueReturns
	fake.recordInvocation("GetIssue", []interface{}{arg1, arg2, arg3, arg4})
	fake.getIssueMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakeClient) GetIssueCallCount() int {
	fake.getIssueMutex.RLock()
	defer fake.getIssueMutex.RUnlock()
	return len(fake.getIssueArgsForCall)
}

func (fake *FakeClient) GetIssueCalls(stub func(context.Context, string, string, int) (*githuba.Issue, *githuba.Response, error)) {
	fake.getIssueMutex.Lock()
	defer fake.getIssueMutex.Unlock()
	fake.GetIssueStub = stub
}

func (fake *FakeClient) GetIssueArgsForCall(i int) (context.Context, string, string, int) {
	fake.getIssueMutex.RLock()
	defer fake.getIssueMutex.RUnlock()
	argsForCall := fake.getIssueArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeClient) GetIssueReturns(result1 *githuba.Issue, result2 *githuba.Response, result3 error) {
	fake.getIssueMutex.Lock()
	defer fake.getIssueMutex.Unlock()
	fake.GetIssueStub = nil
	fake.getIssueReturns = struct {
		result1 *githuba.Issue
		result2 *githuba.Response
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeClient) GetIssueReturnsOnCall(i int, result1 *githuba.Issue, result2 *githuba.Response, result3 error) {
	fake.getIssueMutex.Lock()
	defer fake.getIssueMutex.Unlock()
	fake.GetIssueStub = nil
	if fake.getIssueReturnsOnCall == nil {
		fake.getIssueReturnsOnCall = make(map[int]struct {
			result1 *githuba.Issue
			result2 *githuba.Response
			result3 error
		})
	}
	fake.getIssueReturnsOnCall[i] = struct {
		result1 *githuba.Issue
		result2 *githuba.Response
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeClient) GetPullRequest(arg1 context.Context, arg2 string, arg3 string, arg4 int) (*githuba.PullRequest, *githuba.Response, error) {
	fake.getPullRequestMutex.Lock()
	ret, specificReturn := fake.getPullRequestReturnsOnCall[len(fake.getPullRequestArgsForCall)]
	fake.getPullRequestArgsForCall = append(fake.getPullRequestArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 int
	}{arg1, arg2, arg3, arg4})
	stub := fake.GetPullRequestStub
	fakeReturns := fake.getPullRequestReturns
	fake.recordInvocation("GetPullRequest", []interface{}{arg1, arg2, arg3, arg4})
	fake.getPullRequestMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakeClient) GetPullRequestCallCount() int {
	fake.getPullRequestMutex.RLock()
	defer fake.getPullRequestMutex.RUnlock()
	return len(fake.getPullRequestArgsForCall)
}

func (fake *FakeClient) GetPullRequestCalls(stub func(context.Context, string, string, int) (*githuba.PullRequest, *githuba.Response, error)) {
	fake.getPullRequestMutex.Lock()
	defer fake.getPullRequestMutex.Unlock()
	fake.GetPullRequestStub = stub
}

func (fake *FakeClient) GetPullRequestArgsForCall(i int) (context.Context, string, string, int) {
	fake.getPullRequestMutex.RLock()
	defer fake.getPullRequestMutex.RUnlock()
	argsForCall := fake.getPullRequestArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeClient) GetPullRequestReturns(result1 *githuba.PullRequest, result2 *githuba.Response, result3 error) {
	fake.getPullRequestMutex.Lock()
	defer fake.getPullRequestMutex.Unlock()
	fake.GetPullRequestStub = nil
	fake.getPullRequestReturns = struct {
		result1 *githuba.PullRequest
		result2 *githuba.Response
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeClient) GetPullRequestReturnsOnCall(i int, result1 *githuba.PullRequest, result2 *githuba.Response, result3 error) {
	fake.getPullRequestMutex.Lock()
	defer fake.getPullRequestMutex.Unlock()
	fake.GetPullRequestStub = nil
	if fake.getPullRequestReturnsOnCall == nil {
		fake.getPullRequestReturnsOnCall = make(map[int]struct {
			result1 *githuba.PullRequest
			result2 *githuba.Response
			result3 error
		})
	}
	fake.getPullRequestReturnsOnCall[i] = struct {
		result1 *githuba.PullRequest
		result2 *githuba.Response
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeClient) GetReleaseByTag(arg1 context.Context, arg2 string, arg3 string, arg4 string) (*githuba.RepositoryRelease, *githuba.Response, error) {
	fake.getReleaseByTagMutex.Lock()
	ret, specificReturn := fake.getReleaseByTagReturnsOnCall[len(fake.getReleaseByTagArgsForCall)]
	fake.getReleaseByTagArgsForCall = append(fake.getReleaseByTagArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 string
	}{arg1, arg2, arg3, arg4})
	stub := fake.GetReleaseByTagStub
	fakeReturns := fake.getReleaseByTagReturns
	fake.recordInvocation("GetReleaseByTag", []interface{}{arg1, arg2, arg3, arg4})
	fake.getReleaseByTagMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakeClient) GetReleaseByTagCallCount() int {
	fake.getReleaseByTagMutex.RLock()
	defer fake.getReleaseByTagMutex.RUnlock()
	return len(fake.getReleaseByTagArgsForCall)
}

func (fake *FakeClient) GetReleaseByTagCalls(stub func(context.Context, string, string, string) (*githuba.RepositoryRelease, *githuba.Response, error)) {
	fake.getReleaseByTagMutex.Lock()
	defer fake.getReleaseByTagMutex.Unlock()
	fake.GetReleaseByTagStub = stub
}

func (fake *FakeClient) GetReleaseByTagArgsForCall(i int) (context.Context, string, string, string) {
	fake.getReleaseByTagMutex.RLock()
	defer fake.getReleaseByTagMutex.RUnlock()
	argsForCall := fake.getReleaseByTagArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeClient) GetReleaseByTagReturns(result1 *githuba.RepositoryRelease, result2 *githuba.Response, result3 error) {
	fake.getReleaseByTagMutex.Lock()
	defer fake.getReleaseByTagMutex.Unlock()
	fake.GetReleaseByTagStub = nil
	fake.getReleaseByTagReturns = struct {
		result1 *githuba.RepositoryRelease
		result2 *githuba.Response
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeClient) GetReleaseByTagReturnsOnCall(i int, result1 *githuba.RepositoryRelease, result2 *githuba.Response, result3 error) {
	fake.getReleaseByTagMutex.Lock()
	defer fake.getReleaseByTagMutex.Unlock()
	fake.GetReleaseByTagStub = nil
	if fake.getReleaseByTagReturnsOnCall == nil {
		fake.getReleaseByTagReturnsOnCall = make(map[int]struct {
			result1 *githuba.RepositoryRelease
			result2 *githuba.Response
			result3 error
		})
	}
	fake.getReleaseByTagReturnsOnCall[i] = struct {
		result1 *githuba.RepositoryRelease
		result2 *githuba.Response
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeClient) GetRepoCommit(arg1 context.Context, arg2 string, arg3 string, arg4 string) (*githuba.RepositoryCommit, *githuba.Response, error) {
	fake.getRepoCommitMutex.Lock()
	ret, specificReturn := fake.getRepoCommitReturnsOnCall[len(fake.getRepoCommitArgsForCall)]
	fake.getRepoCommitArgsForCall = append(fake.getRepoCommitArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 string
	}{arg1, arg2, arg3, arg4})
	stub := fake.GetRepoCommitStub
	fakeReturns := fake.getRepoCommitReturns
	fake.recordInvocation("GetRepoCommit", []interface{}{arg1, arg2, arg3, arg4})
	fake.getRepoCommitMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakeClient) GetRepoCommitCallCount() int {
	fake.getRepoCommitMutex.RLock()
	defer fake.getRepoCommitMutex.RUnlock()
	return len(fake.getRepoCommitArgsForCall)
}

func (fake *FakeClient) GetRepoCommitCalls(stub func(context.Context, string, string, string) (*githuba.RepositoryCommit, *githuba.Response, error)) {
	fake.getRepoCommitMutex.Lock()
	defer fake.getRepoCommitMutex.Unlock()
	fake.GetRepoCommitStub = stub
}

func (fake *FakeClient) GetRepoCommitArgsForCall(i int) (context.Context, string, string, string) {
	fake.getRepoCommitMutex.RLock()
	defer fake.getRepoCommitMutex.RUnlock()
	argsForCall := fake.getRepoCommitArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeClient) GetRepoCommitReturns(result1 *githuba.RepositoryCommit, result2 *githuba.Response, result3 error) {
	fake.getRepoCommitMutex.Lock()
	defer fake.getRepoCommitMutex.Unlock()
	fake.GetRepoCommitStub = nil
	fake.getRepoCommitReturns = struct {
		result1 *githuba.RepositoryCommit
		result2 *githuba.Response
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeClient) GetRepoCommitReturnsOnCall(i int, result1 *githuba.RepositoryCommit, result2 *githuba.Response, result3 error) {
	fake.getRepoCommitMutex.Lock()
	defer fake.getRepoCommitMutex.Unlock()
	fake.GetRepoCommitStub = nil
	if fake.getRepoCommitReturnsOnCall == nil {
		fake.getRepoCommitReturnsOnCall = make(map[int]struct {
			result1 *githuba.RepositoryCommit
			result2 *githuba.Response
			result3 error
		})
	}
	fake.getRepoCommitReturnsOnCall[i] = struct {
		result1 *githuba.RepositoryCommit
		result2 *githuba.Response
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeClient) GetRepository(arg1 context.Context, arg2 string, arg3 string) (*githuba.Repository, *githuba.Response, error) {
	fake.getRepositoryMutex.Lock()
	ret, specificReturn := fake.getRepositoryReturnsOnCall[len(fake.getRepositoryArgsForCall)]
	fake.getRepositoryArgsForCall = append(fake.getRepositoryArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 string
	}{arg1, arg2, arg3})
	stub := fake.GetRepositoryStub
	fakeReturns := fake.getRepositoryReturns
	fake.recordInvocation("GetRepository", []interface{}{arg1, arg2, arg3})
	fake.getRepositoryMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakeClient) GetRepositoryCallCount() int {
	fake.getRepositoryMutex.RLock()
	defer fake.getRepositoryMutex.RUnlock()
	return len(fake.getRepositoryArgsForCall)
}

func (fake *FakeClient) GetRepositoryCalls(stub func(context.Context, string, string) (*githuba.Repository, *githuba.Response, error)) {
	fake.getRepositoryMutex.Lock()
	defer fake.getRepositoryMutex.Unlock()
	fake.GetRepositoryStub = stub
}

func (fake *FakeClient) GetRepositoryArgsForCall(i int) (context.Context, string, string) {
	fake.getRepositoryMutex.RLock()
	defer fake.getRepositoryMutex.RUnlock()
	argsForCall := fake.getRepositoryArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeClient) GetRepositoryReturns(result1 *githuba.Repository, result2 *githuba.Response, result3 error) {
	fake.getRepositoryMutex.Lock()
	defer fake.getRepositoryMutex.Unlock()
	fake.GetRepositoryStub = nil
	fake.getRepositoryReturns = struct {
		result1 *githuba.Repository
		result2 *githuba.Response
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeClient) GetRepositoryReturnsOnCall(i int, result1 *githuba.Repository, result2 *githuba.Response, result3 error) {
	fake.getRepositoryMutex.Lock()
	defer fake.getRepositoryMutex.Unlock()
	fake.GetRepositoryStub = nil
	if fake.getRepositoryReturnsOnCall == nil {
		fake.getRepositoryReturnsOnCall = make(map[int]struct {
			result1 *githuba.Repository
			result2 *githuba.Response
			result3 error
		})
	}
	fake.getRepositoryReturnsOnCall[i] = struct {
		result1 *githuba.Repository
		result2 *githuba.Response
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeClient) ListBranches(arg1 context.Context, arg2 string, arg3 string, arg4 *githuba.BranchListOptions) ([]*githuba.Branch, *githuba.Response, error) {
	fake.listBranchesMutex.Lock()
	ret, specificReturn := fake.listBranchesReturnsOnCall[len(fake.listBranchesArgsForCall)]
	fake.listBranchesArgsForCall = append(fake.listBranchesArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 *githuba.BranchListOptions
	}{arg1, arg2, arg3, arg4})
	stub := fake.ListBranchesStub
	fakeReturns := fake.listBranchesReturns
	fake.recordInvocation("ListBranches", []interface{}{arg1, arg2, arg3, arg4})
	fake.listBranchesMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakeClient) ListBranchesCallCount() int {
	fake.listBranchesMutex.RLock()
	defer fake.listBranchesMutex.RUnlock()
	return len(fake.listBranchesArgsForCall)
}

func (fake *FakeClient) ListBranchesCalls(stub func(context.Context, string, string, *githuba.BranchListOptions) ([]*githuba.Branch, *githuba.Response, error)) {
	fake.listBranchesMutex.Lock()
	defer fake.listBranchesMutex.Unlock()
	fake.ListBranchesStub = stub
}

func (fake *FakeClient) ListBranchesArgsForCall(i int) (context.Context, string, string, *githuba.BranchListOptions) {
	fake.listBranchesMutex.RLock()
	defer fake.listBranchesMutex.RUnlock()
	argsForCall := fake.listBranchesArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeClient) ListBranchesReturns(result1 []*githuba.Branch, result2 *githuba.Response, result3 error) {
	fake.listBranchesMutex.Lock()
	defer fake.listBranchesMutex.Unlock()
	fake.ListBranchesStub = nil
	fake.listBranchesReturns = struct {
		result1 []*githuba.Branch
		result2 *githuba.Response
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeClient) ListBranchesReturnsOnCall(i int, result1 []*githuba.Branch, result2 *githuba.Response, result3 error) {
	fake.listBranchesMutex.Lock()
	defer fake.listBranchesMutex.Unlock()
	fake.ListBranchesStub = nil
	if fake.listBranchesReturnsOnCall == nil {
		fake.listBranchesReturnsOnCall = make(map[int]struct {
			result1 []*githuba.Branch
			result2 *githuba.Response
			result3 error
		})
	}
	fake.listBranchesReturnsOnCall[i] = struct {
		result1 []*githuba.Branch
		result2 *githuba.Response
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeClient) ListComments(arg1 context.Context, arg2 string, arg3 string, arg4 int, arg5 *githuba.IssueListCommentsOptions) ([]*githuba.IssueComment, *githuba.Response, error) {
	fake.listCommentsMutex.Lock()
	ret, specificReturn := fake.listCommentsReturnsOnCall[len(fake.listCommentsArgsForCall)]
	fake.listCommentsArgsForCall = append(fake.listCommentsArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 int
		arg5 *githuba.IssueListCommentsOptions
	}{arg1, arg2, arg3, arg4, arg5})
	stub := fake.ListCommentsStub
	fakeReturns := fake.listCommentsReturns
	fake.recordInvocation("ListComments", []interface{}{arg1, arg2, arg3, arg4, arg5})
	fake.listCommentsMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4, arg5)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakeClient) ListCommentsCallCount() int {
	fake.listCommentsMutex.RLock()
	defer fake.listCommentsMutex.RUnlock()
	return len(fake.listCommentsArgsForCall)
}

func (fake *FakeClient) ListCommentsCalls(stub func(context.Context, string, string, int, *githuba.IssueListCommentsOptions) ([]*githuba.IssueComment, *githuba.Response, error)) {
	fake.listCommentsMutex.Lock()
	defer fake.listCommentsMutex.Unlock()
	fake.ListCommentsStub = stub
}

func (fake *FakeClient) ListCommentsArgsForCall(i int) (context.Context, string, string, int, *githuba.IssueListCommentsOptions) {
	fake.listCommentsMutex.RLock()
	defer fake.listCommentsMutex.RUnlock()
	argsForCall := fake.listCommentsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4, argsForCall.arg5
}

func (fake *FakeClient) ListCommentsReturns(result1 []*githuba.IssueComment, result2 *githuba.Response, result3 error) {
	fake.listCommentsMutex.Lock()
	defer fake.listCommentsMutex.Unlock()
	fake.ListCommentsStub = nil
	fake.listCommentsReturns = struct {
		result1 []*githuba.IssueComment
		result2 *githuba.Response
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeClient) ListCommentsReturnsOnCall(i int, result1 []*githuba.IssueComment, result2 *githuba.Response, result3 error) {
	fake.listCommentsMutex.Lock()
	defer fake.listCommentsMutex.Unlock()
	fake.ListCommentsStub = nil
	if fake.listCommentsReturnsOnCall == nil {
		fake.listCommentsReturnsOnCall = make(map[int]struct {
			result1 []*githuba.IssueComment
			result2 *githuba.Response
			result3 error
		})
	}
	fake.listCommentsReturnsOnCall[i] = struct {
		result1 []*githuba.IssueComment
		result2 *githuba.Response
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeClient) ListCommits(arg1 context.Context, arg2 string, arg3 string, arg4 *githuba.CommitsListOptions) ([]*githuba.RepositoryCommit, *githuba.Response, error) {
	fake.listCommitsMutex.Lock()
	ret, specificReturn := fake.listCommitsReturnsOnCall[len(fake.listCommitsArgsForCall)]
	fake.listCommitsArgsForCall = append(fake.listCommitsArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 *githuba.CommitsListOptions
	}{arg1, arg2, arg3, arg4})
	stub := fake.ListCommitsStub
	fakeReturns := fake.listCommitsReturns
	fake.recordInvocation("ListCommits", []interface{}{arg1, arg2, arg3, arg4})
	fake.listCommitsMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakeClient) ListCommitsCallCount() int {
	fake.listCommitsMutex.RLock()
	defer fake.listCommitsMutex.RUnlock()
	return len(fake.listCommitsArgsForCall)
}

func (fake *FakeClient) ListCommitsCalls(stub func(context.Context, string, string, *githuba.CommitsListOptions) ([]*githuba.RepositoryCommit, *githuba.Response, error)) {
	fake.listCommitsMutex.Lock()
	defer fake.listCommitsMutex.Unlock()
	fake.ListCommitsStub = stub
}

func (fake *FakeClient) ListCommitsArgsForCall(i int) (context.Context, string, string, *githuba.CommitsListOptions) {
	fake.listCommitsMutex.RLock()
	defer fake.listCommitsMutex.RUnlock()
	argsForCall := fake.listCommitsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeClient) ListCommitsReturns(result1 []*githuba.RepositoryCommit, result2 *githuba.Response, result3 error) {
	fake.listCommitsMutex.Lock()
	defer fake.listCommitsMutex.Unlock()
	fake.ListCommitsStub = nil
	fake.listCommitsReturns = struct {
		result1 []*githuba.RepositoryCommit
		result2 *githuba.Response
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeClient) ListCommitsReturnsOnCall(i int, result1 []*githuba.RepositoryCommit, result2 *githuba.Response, result3 error) {
	fake.listCommitsMutex.Lock()
	defer fake.listCommitsMutex.Unlock()
	fake.ListCommitsStub = nil
	if fake.listCommitsReturnsOnCall == nil {
		fake.listCommitsReturnsOnCall = make(map[int]struct {
			result1 []*githuba.RepositoryCommit
			result2 *githuba.Response
			result3 error
		})
	}
	fake.listCommitsReturnsOnCall[i] = struct {
		result1 []*githuba.RepositoryCommit
		result2 *githuba.Response
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeClient) ListIssues(arg1 context.Context, arg2 string, arg3 string, arg4 *githuba.IssueListByRepoOptions) ([]*githuba.Issue, *githuba.Response, error) {
	fake.listIssuesMutex.Lock()
	ret, specificReturn := fake.listIssuesReturnsOnCall[len(fake.listIssuesArgsForCall)]
	fake.listIssuesArgsForCall = append(fake.listIssuesArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 *githuba.IssueListByRepoOptions
	}{arg1, arg2, arg3, arg4})
	stub := fake.ListIssuesStub
	fakeReturns := fake.listIssuesReturns
	fake.recordInvocation("ListIssues", []interface{}{arg1, arg2, arg3, arg4})
	fake.listIssuesMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakeClient) ListIssuesCallCount() int {
	fake.listIssuesMutex.RLock()
	defer fake.listIssuesMutex.RUnlock()
	return len(fake.listIssuesArgsForCall)
}

func (fake *FakeClient) ListIssuesCalls(stub func(context.Context, string, string, *githuba.IssueListByRepoOptions) ([]*githuba.Issue, *githuba.Response, error)) {
	fake.listIssuesMutex.Lock()
	defer fake.listIssuesMutex.Unlock()
	fake.ListIssuesStub = stub
}

func (fake *FakeClient) ListIssuesArgsForCall(i int) (context.Context, string, string, *githuba.IssueListByRepoOptions) {
	fake.listIssuesMutex.RLock()
	defer fake.listIssuesMutex.RUnlock()
	argsForCall := fake.listIssuesArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeClient) ListIssuesReturns(result1 []*githuba.Issue, result2 *githuba.Response, result3 error) {
	fake.listIssuesMutex.Lock()
	defer fake.listIssuesMutex.Unlock()
	fake.ListIssuesStub = nil
	fake.listIssuesReturns = struct {
		result1 []*githuba.Issue
		result2 *githuba.Response
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeClient) ListIssuesReturnsOnCall(i int, result1 []*githuba.Issue, result2 *githuba.Response, result3 error) {
	fake.listIssuesMutex.Lock()
	defer fake.listIssuesMutex.Unlock()
	fake.ListIssuesStub = nil
	if fake.listIssuesReturnsOnCall == nil {
		fake.listIssuesReturnsOnCall = make(map[int]struct {
			result1 []*githuba.Issue
			result2 *githuba.Response
			result3 error
		})
	}
	fake.listIssuesReturnsOnCall[i] = struct {
		result1 []*githuba.Issue
		result2 *githuba.Response
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeClient) ListMilestones(arg1 context.Context, arg2 string, arg3 string, arg4 *githuba.MilestoneListOptions) ([]*githuba.Milestone, *githuba.Response, error) {
	fake.listMilestonesMutex.Lock()
	ret, specificReturn := fake.listMilestonesReturnsOnCall[len(fake.listMilestonesArgsForCall)]
	fake.listMilestonesArgsForCall = append(fake.listMilestonesArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 *githuba.MilestoneListOptions
	}{arg1, arg2, arg3, arg4})
	stub := fake.ListMilestonesStub
	fakeReturns := fake.listMilestonesReturns
	fake.recordInvocation("ListMilestones", []interface{}{arg1, arg2, arg3, arg4})
	fake.listMilestonesMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakeClient) ListMilestonesCallCount() int {
	fake.listMilestonesMutex.RLock()
	defer fake.listMilestonesMutex.RUnlock()
	return len(fake.listMilestonesArgsForCall)
}

func (fake *FakeClient) ListMilestonesCalls(stub func(context.Context, string, string, *githuba.MilestoneListOptions) ([]*githuba.Milestone, *githuba.Response, error)) {
	fake.listMilestonesMutex.Lock()
	defer fake.listMilestonesMutex.Unlock()
	fake.ListMilestonesStub = stub
}

func (fake *FakeClient) ListMilestonesArgsForCall(i int) (context.Context, string, string, *githuba.MilestoneListOptions) {
	fake.listMilestonesMutex.RLock()
	defer fake.listMilestonesMutex.RUnlock()
	argsForCall := fake.listMilestonesArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeClient) ListMilestonesReturns(result1 []*githuba.Milestone, result2 *githuba.Response, result3 error) {
	fake.listMilestonesMutex.Lock()
	defer fake.listMilestonesMutex.Unlock()
	fake.ListMilestonesStub = nil
	fake.listMilestonesReturns = struct {
		result1 []*githuba.Milestone
		result2 *githuba.Response
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeClient) ListMilestonesReturnsOnCall(i int, result1 []*githuba.Milestone, result2 *githuba.Response, result3 error) {
	fake.listMilestonesMutex.Lock()
	defer fake.listMilestonesMutex.Unlock()
	fake.ListMilestonesStub = nil
	if fake.listMilestonesReturnsOnCall == nil {
		fake.listMilestonesReturnsOnCall = make(map[int]struct {
			result1 []*githuba.Milestone
			result2 *githuba.Response
			result3 error
		})
	}
	fake.listMilestonesReturnsOnCall[i] = struct {
		result1 []*githuba.Milestone
		result2 *githuba.Response
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeClient) ListPullRequestsWithCommit(arg1 context.Context, arg2 string, arg3 string, arg4 string, arg5 *githuba.ListOptions) ([]*githuba.PullRequest, *githuba.Response, error) {
	fake.listPullRequestsWithCommitMutex.Lock()
	ret, specificReturn := fake.listPullRequestsWithCommitReturnsOnCall[len(fake.listPullRequestsWithCommitArgsForCall)]
	fake.listPullRequestsWithCommitArgsForCall = append(fake.listPullRequestsWithCommitArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 string
		arg5 *githuba.ListOptions
	}{arg1, arg2, arg3, arg4, arg5})
	stub := fake.ListPullRequestsWithCommitStub
	fakeReturns := fake.listPullRequestsWithCommitReturns
	fake.recordInvocation("ListPullRequestsWithCommit", []interface{}{arg1, arg2, arg3, arg4, arg5})
	fake.listPullRequestsWithCommitMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4, arg5)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakeClient) ListPullRequestsWithCommitCallCount() int {
	fake.listPullRequestsWithCommitMutex.RLock()
	defer fake.listPullRequestsWithCommitMutex.RUnlock()
	return len(fake.listPullRequestsWithCommitArgsForCall)
}

func (fake *FakeClient) ListPullRequestsWithCommitCalls(stub func(context.Context, string, string, string, *githuba.ListOptions) ([]*githuba.PullRequest, *githuba.Response, error)) {
	fake.listPullRequestsWithCommitMutex.Lock()
	defer fake.listPullRequestsWithCommitMutex.Unlock()
	fake.ListPullRequestsWithCommitStub = stub
}

func (fake *FakeClient) ListPullRequestsWithCommitArgsForCall(i int) (context.Context, string, string, string, *githuba.ListOptions) {
	fake.listPullRequestsWithCommitMutex.RLock()
	defer fake.listPullRequestsWithCommitMutex.RUnlock()
	argsForCall := fake.listPullRequestsWithCommitArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4, argsForCall.arg5
}

func (fake *FakeClient) ListPullRequestsWithCommitReturns(result1 []*githuba.PullRequest, result2 *githuba.Response, result3 error) {
	fake.listPullRequestsWithCommitMutex.Lock()
	defer fake.listPullRequestsWithCommitMutex.Unlock()
	fake.ListPullRequestsWithCommitStub = nil
	fake.listPullRequestsWithCommitReturns = struct {
		result1 []*githuba.PullRequest
		result2 *githuba.Response
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeClient) ListPullRequestsWithCommitReturnsOnCall(i int, result1 []*githuba.PullRequest, result2 *githuba.Response, result3 error) {
	fake.listPullRequestsWithCommitMutex.Lock()
	defer fake.listPullRequestsWithCommitMutex.Unlock()
	fake.ListPullRequestsWithCommitStub = nil
	if fake.listPullRequestsWithCommitReturnsOnCall == nil {
		fake.listPullRequestsWithCommitReturnsOnCall = make(map[int]struct {
			result1 []*githuba.PullRequest
			result2 *githuba.Response
			result3 error
		})
	}
	fake.listPullRequestsWithCommitReturnsOnCall[i] = struct {
		result1 []*githuba.PullRequest
		result2 *githuba.Response
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeClient) ListReleaseAssets(arg1 context.Context, arg2 string, arg3 string, arg4 int64, arg5 *githuba.ListOptions) ([]*githuba.ReleaseAsset, error) {
	fake.listReleaseAssetsMutex.Lock()
	ret, specificReturn := fake.listReleaseAssetsReturnsOnCall[len(fake.listReleaseAssetsArgsForCall)]
	fake.listReleaseAssetsArgsForCall = append(fake.listReleaseAssetsArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 int64
		arg5 *githuba.ListOptions
	}{arg1, arg2, arg3, arg4, arg5})
	stub := fake.ListReleaseAssetsStub
	fakeReturns := fake.listReleaseAssetsReturns
	fake.recordInvocation("ListReleaseAssets", []interface{}{arg1, arg2, arg3, arg4, arg5})
	fake.listReleaseAssetsMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4, arg5)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeClient) ListReleaseAssetsCallCount() int {
	fake.listReleaseAssetsMutex.RLock()
	defer fake.listReleaseAssetsMutex.RUnlock()
	return len(fake.listReleaseAssetsArgsForCall)
}

func (fake *FakeClient) ListReleaseAssetsCalls(stub func(context.Context, string, string, int64, *githuba.ListOptions) ([]*githuba.ReleaseAsset, error)) {
	fake.listReleaseAssetsMutex.Lock()
	defer fake.listReleaseAssetsMutex.Unlock()
	fake.ListReleaseAssetsStub = stub
}

func (fake *FakeClient) ListReleaseAssetsArgsForCall(i int) (context.Context, string, string, int64, *githuba.ListOptions) {
	fake.listReleaseAssetsMutex.RLock()
	defer fake.listReleaseAssetsMutex.RUnlock()
	argsForCall := fake.listReleaseAssetsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4, argsForCall.arg5
}

func (fake *FakeClient) ListReleaseAssetsReturns(result1 []*githuba.ReleaseAsset, result2 error) {
	fake.listReleaseAssetsMutex.Lock()
	defer fake.listReleaseAssetsMutex.Unlock()
	fake.ListReleaseAssetsStub = nil
	fake.listReleaseAssetsReturns = struct {
		result1 []*githuba.ReleaseAsset
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) ListReleaseAssetsReturnsOnCall(i int, result1 []*githuba.ReleaseAsset, result2 error) {
	fake.listReleaseAssetsMutex.Lock()
	defer fake.listReleaseAssetsMutex.Unlock()
	fake.ListReleaseAssetsStub = nil
	if fake.listReleaseAssetsReturnsOnCall == nil {
		fake.listReleaseAssetsReturnsOnCall = make(map[int]struct {
			result1 []*githuba.ReleaseAsset
			result2 error
		})
	}
	fake.listReleaseAssetsReturnsOnCall[i] = struct {
		result1 []*githuba.ReleaseAsset
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) ListReleases(arg1 context.Context, arg2 string, arg3 string, arg4 *githuba.ListOptions) ([]*githuba.RepositoryRelease, *githuba.Response, error) {
	fake.listReleasesMutex.Lock()
	ret, specificReturn := fake.listReleasesReturnsOnCall[len(fake.listReleasesArgsForCall)]
	fake.listReleasesArgsForCall = append(fake.listReleasesArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 *githuba.ListOptions
	}{arg1, arg2, arg3, arg4})
	stub := fake.ListReleasesStub
	fakeReturns := fake.listReleasesReturns
	fake.recordInvocation("ListReleases", []interface{}{arg1, arg2, arg3, arg4})
	fake.listReleasesMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakeClient) ListReleasesCallCount() int {
	fake.listReleasesMutex.RLock()
	defer fake.listReleasesMutex.RUnlock()
	return len(fake.listReleasesArgsForCall)
}

func (fake *FakeClient) ListReleasesCalls(stub func(context.Context, string, string, *githuba.ListOptions) ([]*githuba.RepositoryRelease, *githuba.Response, error)) {
	fake.listReleasesMutex.Lock()
	defer fake.listReleasesMutex.Unlock()
	fake.ListReleasesStub = stub
}

func (fake *FakeClient) ListReleasesArgsForCall(i int) (context.Context, string, string, *githuba.ListOptions) {
	fake.listReleasesMutex.RLock()
	defer fake.listReleasesMutex.RUnlock()
	argsForCall := fake.listReleasesArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeClient) ListReleasesReturns(result1 []*githuba.RepositoryRelease, result2 *githuba.Response, result3 error) {
	fake.listReleasesMutex.Lock()
	defer fake.listReleasesMutex.Unlock()
	fake.ListReleasesStub = nil
	fake.listReleasesReturns = struct {
		result1 []*githuba.RepositoryRelease
		result2 *githuba.Response
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeClient) ListReleasesReturnsOnCall(i int, result1 []*githuba.RepositoryRelease, result2 *githuba.Response, result3 error) {
	fake.listReleasesMutex.Lock()
	defer fake.listReleasesMutex.Unlock()
	fake.ListReleasesStub = nil
	if fake.listReleasesReturnsOnCall == nil {
		fake.listReleasesReturnsOnCall = make(map[int]struct {
			result1 []*githuba.RepositoryRelease
			result2 *githuba.Response
			result3 error
		})
	}
	fake.listReleasesReturnsOnCall[i] = struct {
		result1 []*githuba.RepositoryRelease
		result2 *githuba.Response
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeClient) ListTags(arg1 context.Context, arg2 string, arg3 string, arg4 *githuba.ListOptions) ([]*githuba.RepositoryTag, *githuba.Response, error) {
	fake.listTagsMutex.Lock()
	ret, specificReturn := fake.listTagsReturnsOnCall[len(fake.listTagsArgsForCall)]
	fake.listTagsArgsForCall = append(fake.listTagsArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 *githuba.ListOptions
	}{arg1, arg2, arg3, arg4})
	stub := fake.ListTagsStub
	fakeReturns := fake.listTagsReturns
	fake.recordInvocation("ListTags", []interface{}{arg1, arg2, arg3, arg4})
	fake.listTagsMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakeClient) ListTagsCallCount() int {
	fake.listTagsMutex.RLock()
	defer fake.listTagsMutex.RUnlock()
	return len(fake.listTagsArgsForCall)
}

func (fake *FakeClient) ListTagsCalls(stub func(context.Context, string, string, *githuba.ListOptions) ([]*githuba.RepositoryTag, *githuba.Response, error)) {
	fake.listTagsMutex.Lock()
	defer fake.listTagsMutex.Unlock()
	fake.ListTagsStub = stub
}

func (fake *FakeClient) ListTagsArgsForCall(i int) (context.Context, string, string, *githuba.ListOptions) {
	fake.listTagsMutex.RLock()
	defer fake.listTagsMutex.RUnlock()
	argsForCall := fake.listTagsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeClient) ListTagsReturns(result1 []*githuba.RepositoryTag, result2 *githuba.Response, result3 error) {
	fake.listTagsMutex.Lock()
	defer fake.listTagsMutex.Unlock()
	fake.ListTagsStub = nil
	fake.listTagsReturns = struct {
		result1 []*githuba.RepositoryTag
		result2 *githuba.Response
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeClient) ListTagsReturnsOnCall(i int, result1 []*githuba.RepositoryTag, result2 *githuba.Response, result3 error) {
	fake.listTagsMutex.Lock()
	defer fake.listTagsMutex.Unlock()
	fake.ListTagsStub = nil
	if fake.listTagsReturnsOnCall == nil {
		fake.listTagsReturnsOnCall = make(map[int]struct {
			result1 []*githuba.RepositoryTag
			result2 *githuba.Response
			result3 error
		})
	}
	fake.listTagsReturnsOnCall[i] = struct {
		result1 []*githuba.RepositoryTag
		result2 *githuba.Response
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeClient) RequestPullRequestReview(arg1 context.Context, arg2 string, arg3 string, arg4 int, arg5 []string, arg6 []string) (*githuba.PullRequest, error) {
	var arg5Copy []string
	if arg5 != nil {
		arg5Copy = make([]string, len(arg5))
		copy(arg5Copy, arg5)
	}
	var arg6Copy []string
	if arg6 != nil {
		arg6Copy = make([]string, len(arg6))
		copy(arg6Copy, arg6)
	}
	fake.requestPullRequestReviewMutex.Lock()
	ret, specificReturn := fake.requestPullRequestReviewReturnsOnCall[len(fake.requestPullRequestReviewArgsForCall)]
	fake.requestPullRequestReviewArgsForCall = append(fake.requestPullRequestReviewArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 int
		arg5 []string
		arg6 []string
	}{arg1, arg2, arg3, arg4, arg5Copy, arg6Copy})
	stub := fake.RequestPullRequestReviewStub
	fakeReturns := fake.requestPullRequestReviewReturns
	fake.recordInvocation("RequestPullRequestReview", []interface{}{arg1, arg2, arg3, arg4, arg5Copy, arg6Copy})
	fake.requestPullRequestReviewMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4, arg5, arg6)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeClient) RequestPullRequestReviewCallCount() int {
	fake.requestPullRequestReviewMutex.RLock()
	defer fake.requestPullRequestReviewMutex.RUnlock()
	return len(fake.requestPullRequestReviewArgsForCall)
}

func (fake *FakeClient) RequestPullRequestReviewCalls(stub func(context.Context, string, string, int, []string, []string) (*githuba.PullRequest, error)) {
	fake.requestPullRequestReviewMutex.Lock()
	defer fake.requestPullRequestReviewMutex.Unlock()
	fake.RequestPullRequestReviewStub = stub
}

func (fake *FakeClient) RequestPullRequestReviewArgsForCall(i int) (context.Context, string, string, int, []string, []string) {
	fake.requestPullRequestReviewMutex.RLock()
	defer fake.requestPullRequestReviewMutex.RUnlock()
	argsForCall := fake.requestPullRequestReviewArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4, argsForCall.arg5, argsForCall.arg6
}

func (fake *FakeClient) RequestPullRequestReviewReturns(result1 *githuba.PullRequest, result2 error) {
	fake.requestPullRequestReviewMutex.Lock()
	defer fake.requestPullRequestReviewMutex.Unlock()
	fake.RequestPullRequestReviewStub = nil
	fake.requestPullRequestReviewReturns = struct {
		result1 *githuba.PullRequest
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) RequestPullRequestReviewReturnsOnCall(i int, result1 *githuba.PullRequest, result2 error) {
	fake.requestPullRequestReviewMutex.Lock()
	defer fake.requestPullRequestReviewMutex.Unlock()
	fake.RequestPullRequestReviewStub = nil
	if fake.requestPullRequestReviewReturnsOnCall == nil {
		fake.requestPullRequestReviewReturnsOnCall = make(map[int]struct {
			result1 *githuba.PullRequest
			result2 error
		})
	}
	fake.requestPullRequestReviewReturnsOnCall[i] = struct {
		result1 *githuba.PullRequest
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) UpdateIssue(arg1 context.Context, arg2 string, arg3 string, arg4 int, arg5 *githuba.IssueRequest) (*githuba.Issue, *githuba.Response, error) {
	fake.updateIssueMutex.Lock()
	ret, specificReturn := fake.updateIssueReturnsOnCall[len(fake.updateIssueArgsForCall)]
	fake.updateIssueArgsForCall = append(fake.updateIssueArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 int
		arg5 *githuba.IssueRequest
	}{arg1, arg2, arg3, arg4, arg5})
	stub := fake.UpdateIssueStub
	fakeReturns := fake.updateIssueReturns
	fake.recordInvocation("UpdateIssue", []interface{}{arg1, arg2, arg3, arg4, arg5})
	fake.updateIssueMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4, arg5)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakeClient) UpdateIssueCallCount() int {
	fake.updateIssueMutex.RLock()
	defer fake.updateIssueMutex.RUnlock()
	return len(fake.updateIssueArgsForCall)
}

func (fake *FakeClient) UpdateIssueCalls(stub func(context.Context, string, string, int, *githuba.IssueRequest) (*githuba.Issue, *githuba.Response, error)) {
	fake.updateIssueMutex.Lock()
	defer fake.updateIssueMutex.Unlock()
	fake.UpdateIssueStub = stub
}

func (fake *FakeClient) UpdateIssueArgsForCall(i int) (context.Context, string, string, int, *githuba.IssueRequest) {
	fake.updateIssueMutex.RLock()
	defer fake.updateIssueMutex.RUnlock()
	argsForCall := fake.updateIssueArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4, argsForCall.arg5
}

func (fake *FakeClient) UpdateIssueReturns(result1 *githuba.Issue, result2 *githuba.Response, result3 error) {
	fake.updateIssueMutex.Lock()
	defer fake.updateIssueMutex.Unlock()
	fake.UpdateIssueStub = nil
	fake.updateIssueReturns = struct {
		result1 *githuba.Issue
		result2 *githuba.Response
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeClient) UpdateIssueReturnsOnCall(i int, result1 *githuba.Issue, result2 *githuba.Response, result3 error) {
	fake.updateIssueMutex.Lock()
	defer fake.updateIssueMutex.Unlock()
	fake.UpdateIssueStub = nil
	if fake.updateIssueReturnsOnCall == nil {
		fake.updateIssueReturnsOnCall = make(map[int]struct {
			result1 *githuba.Issue
			result2 *githuba.Response
			result3 error
		})
	}
	fake.updateIssueReturnsOnCall[i] = struct {
		result1 *githuba.Issue
		result2 *githuba.Response
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeClient) UpdateReleasePage(arg1 context.Context, arg2 string, arg3 string, arg4 int64, arg5 *githuba.RepositoryRelease) (*githuba.RepositoryRelease, error) {
	fake.updateReleasePageMutex.Lock()
	ret, specificReturn := fake.updateReleasePageReturnsOnCall[len(fake.updateReleasePageArgsForCall)]
	fake.updateReleasePageArgsForCall = append(fake.updateReleasePageArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 int64
		arg5 *githuba.RepositoryRelease
	}{arg1, arg2, arg3, arg4, arg5})
	stub := fake.UpdateReleasePageStub
	fakeReturns := fake.updateReleasePageReturns
	fake.recordInvocation("UpdateReleasePage", []interface{}{arg1, arg2, arg3, arg4, arg5})
	fake.updateReleasePageMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4, arg5)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeClient) UpdateReleasePageCallCount() int {
	fake.updateReleasePageMutex.RLock()
	defer fake.updateReleasePageMutex.RUnlock()
	return len(fake.updateReleasePageArgsForCall)
}

func (fake *FakeClient) UpdateReleasePageCalls(stub func(context.Context, string, string, int64, *githuba.RepositoryRelease) (*githuba.RepositoryRelease, error)) {
	fake.updateReleasePageMutex.Lock()
	defer fake.updateReleasePageMutex.Unlock()
	fake.UpdateReleasePageStub = stub
}

func (fake *FakeClient) UpdateReleasePageArgsForCall(i int) (context.Context, string, string, int64, *githuba.RepositoryRelease) {
	fake.updateReleasePageMutex.RLock()
	defer fake.updateReleasePageMutex.RUnlock()
	argsForCall := fake.updateReleasePageArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4, argsForCall.arg5
}

func (fake *FakeClient) UpdateReleasePageReturns(result1 *githuba.RepositoryRelease, result2 error) {
	fake.updateReleasePageMutex.Lock()
	defer fake.updateReleasePageMutex.Unlock()
	fake.UpdateReleasePageStub = nil
	fake.updateReleasePageReturns = struct {
		result1 *githuba.RepositoryRelease
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) UpdateReleasePageReturnsOnCall(i int, result1 *githuba.RepositoryRelease, result2 error) {
	fake.updateReleasePageMutex.Lock()
	defer fake.updateReleasePageMutex.Unlock()
	fake.UpdateReleasePageStub = nil
	if fake.updateReleasePageReturnsOnCall == nil {
		fake.updateReleasePageReturnsOnCall = make(map[int]struct {
			result1 *githuba.RepositoryRelease
			result2 error
		})
	}
	fake.updateReleasePageReturnsOnCall[i] = struct {
		result1 *githuba.RepositoryRelease
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) UploadReleaseAsset(arg1 context.Context, arg2 string, arg3 string, arg4 int64, arg5 *githuba.UploadOptions, arg6 *os.File) (*githuba.ReleaseAsset, error) {
	fake.uploadReleaseAssetMutex.Lock()
	ret, specificReturn := fake.uploadReleaseAssetReturnsOnCall[len(fake.uploadReleaseAssetArgsForCall)]
	fake.uploadReleaseAssetArgsForCall = append(fake.uploadReleaseAssetArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 int64
		arg5 *githuba.UploadOptions
		arg6 *os.File
	}{arg1, arg2, arg3, arg4, arg5, arg6})
	stub := fake.UploadReleaseAssetStub
	fakeReturns := fake.uploadReleaseAssetReturns
	fake.recordInvocation("UploadReleaseAsset", []interface{}{arg1, arg2, arg3, arg4, arg5, arg6})
	fake.uploadReleaseAssetMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4, arg5, arg6)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeClient) UploadReleaseAssetCallCount() int {
	fake.uploadReleaseAssetMutex.RLock()
	defer fake.uploadReleaseAssetMutex.RUnlock()
	return len(fake.uploadReleaseAssetArgsForCall)
}

func (fake *FakeClient) UploadReleaseAssetCalls(stub func(context.Context, string, string, int64, *githuba.UploadOptions, *os.File) (*githuba.ReleaseAsset, error)) {
	fake.uploadReleaseAssetMutex.Lock()
	defer fake.uploadReleaseAssetMutex.Unlock()
	fake.UploadReleaseAssetStub = stub
}

func (fake *FakeClient) UploadReleaseAssetArgsForCall(i int) (context.Context, string, string, int64, *githuba.UploadOptions, *os.File) {
	fake.uploadReleaseAssetMutex.RLock()
	defer fake.uploadReleaseAssetMutex.RUnlock()
	argsForCall := fake.uploadReleaseAssetArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4, argsForCall.arg5, argsForCall.arg6
}

func (fake *FakeClient) UploadReleaseAssetReturns(result1 *githuba.ReleaseAsset, result2 error) {
	fake.uploadReleaseAssetMutex.Lock()
	defer fake.uploadReleaseAssetMutex.Unlock()
	fake.UploadReleaseAssetStub = nil
	fake.uploadReleaseAssetReturns = struct {
		result1 *githuba.ReleaseAsset
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) UploadReleaseAssetReturnsOnCall(i int, result1 *githuba.ReleaseAsset, result2 error) {
	fake.uploadReleaseAssetMutex.Lock()
	defer fake.uploadReleaseAssetMutex.Unlock()
	fake.UploadReleaseAssetStub = nil
	if fake.uploadReleaseAssetReturnsOnCall == nil {
		fake.uploadReleaseAssetReturnsOnCall = make(map[int]struct {
			result1 *githuba.ReleaseAsset
			result2 error
		})
	}
	fake.uploadReleaseAssetReturnsOnCall[i] = struct {
		result1 *githuba.ReleaseAsset
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeClient) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ github.Client = new(FakeClient)
