/*
Copyright The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by counterfeiter. DO NOT EDIT.
package signfakes

import (
	"context"
	"net/http"
	"sync"

	"github.com/google/go-containerregistry/pkg/authn"
	"github.com/google/go-containerregistry/pkg/crane"
	"github.com/google/go-containerregistry/pkg/name"
	"github.com/sigstore/cosign/v2/cmd/cosign/cli/options"
	"github.com/sigstore/rekor/pkg/generated/client"
	"github.com/sigstore/rekor/pkg/generated/models"
	"github.com/sirupsen/logrus"
	"sigs.k8s.io/release-sdk/sign"
)

type FakeImpl struct {
	DigestStub        func(string, ...crane.Option) (string, error)
	digestMutex       sync.RWMutex
	digestArgsForCall []struct {
		arg1 string
		arg2 []crane.Option
	}
	digestReturns struct {
		result1 string
		result2 error
	}
	digestReturnsOnCall map[int]struct {
		result1 string
		result2 error
	}
	EnvDefaultStub        func(string, string) string
	envDefaultMutex       sync.RWMutex
	envDefaultArgsForCall []struct {
		arg1 string
		arg2 string
	}
	envDefaultReturns struct {
		result1 string
	}
	envDefaultReturnsOnCall map[int]struct {
		result1 string
	}
	FileExistsStub        func(string) bool
	fileExistsMutex       sync.RWMutex
	fileExistsArgsForCall []struct {
		arg1 string
	}
	fileExistsReturns struct {
		result1 bool
	}
	fileExistsReturnsOnCall map[int]struct {
		result1 bool
	}
	FindTlogEntryStub        func(context.Context, *client.Rekor, string, []byte, []byte) ([]models.LogEntryAnon, error)
	findTlogEntryMutex       sync.RWMutex
	findTlogEntryArgsForCall []struct {
		arg1 context.Context
		arg2 *client.Rekor
		arg3 string
		arg4 []byte
		arg5 []byte
	}
	findTlogEntryReturns struct {
		result1 []models.LogEntryAnon
		result2 error
	}
	findTlogEntryReturnsOnCall map[int]struct {
		result1 []models.LogEntryAnon
		result2 error
	}
	ImagesSignedStub        func(context.Context, *sign.Signer, ...string) (*sync.Map, error)
	imagesSignedMutex       sync.RWMutex
	imagesSignedArgsForCall []struct {
		arg1 context.Context
		arg2 *sign.Signer
		arg3 []string
	}
	imagesSignedReturns struct {
		result1 *sync.Map
		result2 error
	}
	imagesSignedReturnsOnCall map[int]struct {
		result1 *sync.Map
		result2 error
	}
	NewRekorClientStub        func(string) (*client.Rekor, error)
	newRekorClientMutex       sync.RWMutex
	newRekorClientArgsForCall []struct {
		arg1 string
	}
	newRekorClientReturns struct {
		result1 *client.Rekor
		result2 error
	}
	newRekorClientReturnsOnCall map[int]struct {
		result1 *client.Rekor
		result2 error
	}
	NewWithContextStub        func(context.Context, name.Registry, authn.Authenticator, http.RoundTripper, []string) (http.RoundTripper, error)
	newWithContextMutex       sync.RWMutex
	newWithContextArgsForCall []struct {
		arg1 context.Context
		arg2 name.Registry
		arg3 authn.Authenticator
		arg4 http.RoundTripper
		arg5 []string
	}
	newWithContextReturns struct {
		result1 http.RoundTripper
		result2 error
	}
	newWithContextReturnsOnCall map[int]struct {
		result1 http.RoundTripper
		result2 error
	}
	ParseReferenceStub        func(string, ...name.Option) (name.Reference, error)
	parseReferenceMutex       sync.RWMutex
	parseReferenceArgsForCall []struct {
		arg1 string
		arg2 []name.Option
	}
	parseReferenceReturns struct {
		result1 name.Reference
		result2 error
	}
	parseReferenceReturnsOnCall map[int]struct {
		result1 name.Reference
		result2 error
	}
	PayloadBytesStub        func(string) ([]byte, error)
	payloadBytesMutex       sync.RWMutex
	payloadBytesArgsForCall []struct {
		arg1 string
	}
	payloadBytesReturns struct {
		result1 []byte
		result2 error
	}
	payloadBytesReturnsOnCall map[int]struct {
		result1 []byte
		result2 error
	}
	SetenvStub        func(string, string) error
	setenvMutex       sync.RWMutex
	setenvArgsForCall []struct {
		arg1 string
		arg2 string
	}
	setenvReturns struct {
		result1 error
	}
	setenvReturnsOnCall map[int]struct {
		result1 error
	}
	SignFileInternalStub        func(options.RootOptions, options.KeyOpts, string, bool, string, string, bool) error
	signFileInternalMutex       sync.RWMutex
	signFileInternalArgsForCall []struct {
		arg1 options.RootOptions
		arg2 options.KeyOpts
		arg3 string
		arg4 bool
		arg5 string
		arg6 string
		arg7 bool
	}
	signFileInternalReturns struct {
		result1 error
	}
	signFileInternalReturnsOnCall map[int]struct {
		result1 error
	}
	SignImageInternalStub        func(options.RootOptions, options.KeyOpts, options.SignOptions, []string) error
	signImageInternalMutex       sync.RWMutex
	signImageInternalArgsForCall []struct {
		arg1 options.RootOptions
		arg2 options.KeyOpts
		arg3 options.SignOptions
		arg4 []string
	}
	signImageInternalReturns struct {
		result1 error
	}
	signImageInternalReturnsOnCall map[int]struct {
		result1 error
	}
	TokenFromProvidersStub        func(context.Context, *logrus.Logger) (string, error)
	tokenFromProvidersMutex       sync.RWMutex
	tokenFromProvidersArgsForCall []struct {
		arg1 context.Context
		arg2 *logrus.Logger
	}
	tokenFromProvidersReturns struct {
		result1 string
		result2 error
	}
	tokenFromProvidersReturnsOnCall map[int]struct {
		result1 string
		result2 error
	}
	VerifyFileInternalStub        func(context.Context, options.KeyOpts, options.CertVerifyOptions, string, string) error
	verifyFileInternalMutex       sync.RWMutex
	verifyFileInternalArgsForCall []struct {
		arg1 context.Context
		arg2 options.KeyOpts
		arg3 options.CertVerifyOptions
		arg4 string
		arg5 string
	}
	verifyFileInternalReturns struct {
		result1 error
	}
	verifyFileInternalReturnsOnCall map[int]struct {
		result1 error
	}
	VerifyImageInternalStub        func(context.Context, options.CertVerifyOptions, string, []string, bool) (*sign.SignedObject, error)
	verifyImageInternalMutex       sync.RWMutex
	verifyImageInternalArgsForCall []struct {
		arg1 context.Context
		arg2 options.CertVerifyOptions
		arg3 string
		arg4 []string
		arg5 bool
	}
	verifyImageInternalReturns struct {
		result1 *sign.SignedObject
		result2 error
	}
	verifyImageInternalReturnsOnCall map[int]struct {
		result1 *sign.SignedObject
		result2 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeImpl) Digest(arg1 string, arg2 ...crane.Option) (string, error) {
	fake.digestMutex.Lock()
	ret, specificReturn := fake.digestReturnsOnCall[len(fake.digestArgsForCall)]
	fake.digestArgsForCall = append(fake.digestArgsForCall, struct {
		arg1 string
		arg2 []crane.Option
	}{arg1, arg2})
	stub := fake.DigestStub
	fakeReturns := fake.digestReturns
	fake.recordInvocation("Digest", []interface{}{arg1, arg2})
	fake.digestMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeImpl) DigestCallCount() int {
	fake.digestMutex.RLock()
	defer fake.digestMutex.RUnlock()
	return len(fake.digestArgsForCall)
}

func (fake *FakeImpl) DigestCalls(stub func(string, ...crane.Option) (string, error)) {
	fake.digestMutex.Lock()
	defer fake.digestMutex.Unlock()
	fake.DigestStub = stub
}

func (fake *FakeImpl) DigestArgsForCall(i int) (string, []crane.Option) {
	fake.digestMutex.RLock()
	defer fake.digestMutex.RUnlock()
	argsForCall := fake.digestArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeImpl) DigestReturns(result1 string, result2 error) {
	fake.digestMutex.Lock()
	defer fake.digestMutex.Unlock()
	fake.DigestStub = nil
	fake.digestReturns = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeImpl) DigestReturnsOnCall(i int, result1 string, result2 error) {
	fake.digestMutex.Lock()
	defer fake.digestMutex.Unlock()
	fake.DigestStub = nil
	if fake.digestReturnsOnCall == nil {
		fake.digestReturnsOnCall = make(map[int]struct {
			result1 string
			result2 error
		})
	}
	fake.digestReturnsOnCall[i] = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeImpl) EnvDefault(arg1 string, arg2 string) string {
	fake.envDefaultMutex.Lock()
	ret, specificReturn := fake.envDefaultReturnsOnCall[len(fake.envDefaultArgsForCall)]
	fake.envDefaultArgsForCall = append(fake.envDefaultArgsForCall, struct {
		arg1 string
		arg2 string
	}{arg1, arg2})
	stub := fake.EnvDefaultStub
	fakeReturns := fake.envDefaultReturns
	fake.recordInvocation("EnvDefault", []interface{}{arg1, arg2})
	fake.envDefaultMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeImpl) EnvDefaultCallCount() int {
	fake.envDefaultMutex.RLock()
	defer fake.envDefaultMutex.RUnlock()
	return len(fake.envDefaultArgsForCall)
}

func (fake *FakeImpl) EnvDefaultCalls(stub func(string, string) string) {
	fake.envDefaultMutex.Lock()
	defer fake.envDefaultMutex.Unlock()
	fake.EnvDefaultStub = stub
}

func (fake *FakeImpl) EnvDefaultArgsForCall(i int) (string, string) {
	fake.envDefaultMutex.RLock()
	defer fake.envDefaultMutex.RUnlock()
	argsForCall := fake.envDefaultArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeImpl) EnvDefaultReturns(result1 string) {
	fake.envDefaultMutex.Lock()
	defer fake.envDefaultMutex.Unlock()
	fake.EnvDefaultStub = nil
	fake.envDefaultReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeImpl) EnvDefaultReturnsOnCall(i int, result1 string) {
	fake.envDefaultMutex.Lock()
	defer fake.envDefaultMutex.Unlock()
	fake.EnvDefaultStub = nil
	if fake.envDefaultReturnsOnCall == nil {
		fake.envDefaultReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.envDefaultReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeImpl) FileExists(arg1 string) bool {
	fake.fileExistsMutex.Lock()
	ret, specificReturn := fake.fileExistsReturnsOnCall[len(fake.fileExistsArgsForCall)]
	fake.fileExistsArgsForCall = append(fake.fileExistsArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.FileExistsStub
	fakeReturns := fake.fileExistsReturns
	fake.recordInvocation("FileExists", []interface{}{arg1})
	fake.fileExistsMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeImpl) FileExistsCallCount() int {
	fake.fileExistsMutex.RLock()
	defer fake.fileExistsMutex.RUnlock()
	return len(fake.fileExistsArgsForCall)
}

func (fake *FakeImpl) FileExistsCalls(stub func(string) bool) {
	fake.fileExistsMutex.Lock()
	defer fake.fileExistsMutex.Unlock()
	fake.FileExistsStub = stub
}

func (fake *FakeImpl) FileExistsArgsForCall(i int) string {
	fake.fileExistsMutex.RLock()
	defer fake.fileExistsMutex.RUnlock()
	argsForCall := fake.fileExistsArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeImpl) FileExistsReturns(result1 bool) {
	fake.fileExistsMutex.Lock()
	defer fake.fileExistsMutex.Unlock()
	fake.FileExistsStub = nil
	fake.fileExistsReturns = struct {
		result1 bool
	}{result1}
}

func (fake *FakeImpl) FileExistsReturnsOnCall(i int, result1 bool) {
	fake.fileExistsMutex.Lock()
	defer fake.fileExistsMutex.Unlock()
	fake.FileExistsStub = nil
	if fake.fileExistsReturnsOnCall == nil {
		fake.fileExistsReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.fileExistsReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *FakeImpl) FindTlogEntry(arg1 context.Context, arg2 *client.Rekor, arg3 string, arg4 []byte, arg5 []byte) ([]models.LogEntryAnon, error) {
	var arg4Copy []byte
	if arg4 != nil {
		arg4Copy = make([]byte, len(arg4))
		copy(arg4Copy, arg4)
	}
	var arg5Copy []byte
	if arg5 != nil {
		arg5Copy = make([]byte, len(arg5))
		copy(arg5Copy, arg5)
	}
	fake.findTlogEntryMutex.Lock()
	ret, specificReturn := fake.findTlogEntryReturnsOnCall[len(fake.findTlogEntryArgsForCall)]
	fake.findTlogEntryArgsForCall = append(fake.findTlogEntryArgsForCall, struct {
		arg1 context.Context
		arg2 *client.Rekor
		arg3 string
		arg4 []byte
		arg5 []byte
	}{arg1, arg2, arg3, arg4Copy, arg5Copy})
	stub := fake.FindTlogEntryStub
	fakeReturns := fake.findTlogEntryReturns
	fake.recordInvocation("FindTlogEntry", []interface{}{arg1, arg2, arg3, arg4Copy, arg5Copy})
	fake.findTlogEntryMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4, arg5)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeImpl) FindTlogEntryCallCount() int {
	fake.findTlogEntryMutex.RLock()
	defer fake.findTlogEntryMutex.RUnlock()
	return len(fake.findTlogEntryArgsForCall)
}

func (fake *FakeImpl) FindTlogEntryCalls(stub func(context.Context, *client.Rekor, string, []byte, []byte) ([]models.LogEntryAnon, error)) {
	fake.findTlogEntryMutex.Lock()
	defer fake.findTlogEntryMutex.Unlock()
	fake.FindTlogEntryStub = stub
}

func (fake *FakeImpl) FindTlogEntryArgsForCall(i int) (context.Context, *client.Rekor, string, []byte, []byte) {
	fake.findTlogEntryMutex.RLock()
	defer fake.findTlogEntryMutex.RUnlock()
	argsForCall := fake.findTlogEntryArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4, argsForCall.arg5
}

func (fake *FakeImpl) FindTlogEntryReturns(result1 []models.LogEntryAnon, result2 error) {
	fake.findTlogEntryMutex.Lock()
	defer fake.findTlogEntryMutex.Unlock()
	fake.FindTlogEntryStub = nil
	fake.findTlogEntryReturns = struct {
		result1 []models.LogEntryAnon
		result2 error
	}{result1, result2}
}

func (fake *FakeImpl) FindTlogEntryReturnsOnCall(i int, result1 []models.LogEntryAnon, result2 error) {
	fake.findTlogEntryMutex.Lock()
	defer fake.findTlogEntryMutex.Unlock()
	fake.FindTlogEntryStub = nil
	if fake.findTlogEntryReturnsOnCall == nil {
		fake.findTlogEntryReturnsOnCall = make(map[int]struct {
			result1 []models.LogEntryAnon
			result2 error
		})
	}
	fake.findTlogEntryReturnsOnCall[i] = struct {
		result1 []models.LogEntryAnon
		result2 error
	}{result1, result2}
}

func (fake *FakeImpl) ImagesSigned(arg1 context.Context, arg2 *sign.Signer, arg3 ...string) (*sync.Map, error) {
	fake.imagesSignedMutex.Lock()
	ret, specificReturn := fake.imagesSignedReturnsOnCall[len(fake.imagesSignedArgsForCall)]
	fake.imagesSignedArgsForCall = append(fake.imagesSignedArgsForCall, struct {
		arg1 context.Context
		arg2 *sign.Signer
		arg3 []string
	}{arg1, arg2, arg3})
	stub := fake.ImagesSignedStub
	fakeReturns := fake.imagesSignedReturns
	fake.recordInvocation("ImagesSigned", []interface{}{arg1, arg2, arg3})
	fake.imagesSignedMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeImpl) ImagesSignedCallCount() int {
	fake.imagesSignedMutex.RLock()
	defer fake.imagesSignedMutex.RUnlock()
	return len(fake.imagesSignedArgsForCall)
}

func (fake *FakeImpl) ImagesSignedCalls(stub func(context.Context, *sign.Signer, ...string) (*sync.Map, error)) {
	fake.imagesSignedMutex.Lock()
	defer fake.imagesSignedMutex.Unlock()
	fake.ImagesSignedStub = stub
}

func (fake *FakeImpl) ImagesSignedArgsForCall(i int) (context.Context, *sign.Signer, []string) {
	fake.imagesSignedMutex.RLock()
	defer fake.imagesSignedMutex.RUnlock()
	argsForCall := fake.imagesSignedArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeImpl) ImagesSignedReturns(result1 *sync.Map, result2 error) {
	fake.imagesSignedMutex.Lock()
	defer fake.imagesSignedMutex.Unlock()
	fake.ImagesSignedStub = nil
	fake.imagesSignedReturns = struct {
		result1 *sync.Map
		result2 error
	}{result1, result2}
}

func (fake *FakeImpl) ImagesSignedReturnsOnCall(i int, result1 *sync.Map, result2 error) {
	fake.imagesSignedMutex.Lock()
	defer fake.imagesSignedMutex.Unlock()
	fake.ImagesSignedStub = nil
	if fake.imagesSignedReturnsOnCall == nil {
		fake.imagesSignedReturnsOnCall = make(map[int]struct {
			result1 *sync.Map
			result2 error
		})
	}
	fake.imagesSignedReturnsOnCall[i] = struct {
		result1 *sync.Map
		result2 error
	}{result1, result2}
}

func (fake *FakeImpl) NewRekorClient(arg1 string) (*client.Rekor, error) {
	fake.newRekorClientMutex.Lock()
	ret, specificReturn := fake.newRekorClientReturnsOnCall[len(fake.newRekorClientArgsForCall)]
	fake.newRekorClientArgsForCall = append(fake.newRekorClientArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.NewRekorClientStub
	fakeReturns := fake.newRekorClientReturns
	fake.recordInvocation("NewRekorClient", []interface{}{arg1})
	fake.newRekorClientMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeImpl) NewRekorClientCallCount() int {
	fake.newRekorClientMutex.RLock()
	defer fake.newRekorClientMutex.RUnlock()
	return len(fake.newRekorClientArgsForCall)
}

func (fake *FakeImpl) NewRekorClientCalls(stub func(string) (*client.Rekor, error)) {
	fake.newRekorClientMutex.Lock()
	defer fake.newRekorClientMutex.Unlock()
	fake.NewRekorClientStub = stub
}

func (fake *FakeImpl) NewRekorClientArgsForCall(i int) string {
	fake.newRekorClientMutex.RLock()
	defer fake.newRekorClientMutex.RUnlock()
	argsForCall := fake.newRekorClientArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeImpl) NewRekorClientReturns(result1 *client.Rekor, result2 error) {
	fake.newRekorClientMutex.Lock()
	defer fake.newRekorClientMutex.Unlock()
	fake.NewRekorClientStub = nil
	fake.newRekorClientReturns = struct {
		result1 *client.Rekor
		result2 error
	}{result1, result2}
}

func (fake *FakeImpl) NewRekorClientReturnsOnCall(i int, result1 *client.Rekor, result2 error) {
	fake.newRekorClientMutex.Lock()
	defer fake.newRekorClientMutex.Unlock()
	fake.NewRekorClientStub = nil
	if fake.newRekorClientReturnsOnCall == nil {
		fake.newRekorClientReturnsOnCall = make(map[int]struct {
			result1 *client.Rekor
			result2 error
		})
	}
	fake.newRekorClientReturnsOnCall[i] = struct {
		result1 *client.Rekor
		result2 error
	}{result1, result2}
}

func (fake *FakeImpl) NewWithContext(arg1 context.Context, arg2 name.Registry, arg3 authn.Authenticator, arg4 http.RoundTripper, arg5 []string) (http.RoundTripper, error) {
	var arg5Copy []string
	if arg5 != nil {
		arg5Copy = make([]string, len(arg5))
		copy(arg5Copy, arg5)
	}
	fake.newWithContextMutex.Lock()
	ret, specificReturn := fake.newWithContextReturnsOnCall[len(fake.newWithContextArgsForCall)]
	fake.newWithContextArgsForCall = append(fake.newWithContextArgsForCall, struct {
		arg1 context.Context
		arg2 name.Registry
		arg3 authn.Authenticator
		arg4 http.RoundTripper
		arg5 []string
	}{arg1, arg2, arg3, arg4, arg5Copy})
	stub := fake.NewWithContextStub
	fakeReturns := fake.newWithContextReturns
	fake.recordInvocation("NewWithContext", []interface{}{arg1, arg2, arg3, arg4, arg5Copy})
	fake.newWithContextMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4, arg5)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeImpl) NewWithContextCallCount() int {
	fake.newWithContextMutex.RLock()
	defer fake.newWithContextMutex.RUnlock()
	return len(fake.newWithContextArgsForCall)
}

func (fake *FakeImpl) NewWithContextCalls(stub func(context.Context, name.Registry, authn.Authenticator, http.RoundTripper, []string) (http.RoundTripper, error)) {
	fake.newWithContextMutex.Lock()
	defer fake.newWithContextMutex.Unlock()
	fake.NewWithContextStub = stub
}

func (fake *FakeImpl) NewWithContextArgsForCall(i int) (context.Context, name.Registry, authn.Authenticator, http.RoundTripper, []string) {
	fake.newWithContextMutex.RLock()
	defer fake.newWithContextMutex.RUnlock()
	argsForCall := fake.newWithContextArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4, argsForCall.arg5
}

func (fake *FakeImpl) NewWithContextReturns(result1 http.RoundTripper, result2 error) {
	fake.newWithContextMutex.Lock()
	defer fake.newWithContextMutex.Unlock()
	fake.NewWithContextStub = nil
	fake.newWithContextReturns = struct {
		result1 http.RoundTripper
		result2 error
	}{result1, result2}
}

func (fake *FakeImpl) NewWithContextReturnsOnCall(i int, result1 http.RoundTripper, result2 error) {
	fake.newWithContextMutex.Lock()
	defer fake.newWithContextMutex.Unlock()
	fake.NewWithContextStub = nil
	if fake.newWithContextReturnsOnCall == nil {
		fake.newWithContextReturnsOnCall = make(map[int]struct {
			result1 http.RoundTripper
			result2 error
		})
	}
	fake.newWithContextReturnsOnCall[i] = struct {
		result1 http.RoundTripper
		result2 error
	}{result1, result2}
}

func (fake *FakeImpl) ParseReference(arg1 string, arg2 ...name.Option) (name.Reference, error) {
	fake.parseReferenceMutex.Lock()
	ret, specificReturn := fake.parseReferenceReturnsOnCall[len(fake.parseReferenceArgsForCall)]
	fake.parseReferenceArgsForCall = append(fake.parseReferenceArgsForCall, struct {
		arg1 string
		arg2 []name.Option
	}{arg1, arg2})
	stub := fake.ParseReferenceStub
	fakeReturns := fake.parseReferenceReturns
	fake.recordInvocation("ParseReference", []interface{}{arg1, arg2})
	fake.parseReferenceMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeImpl) ParseReferenceCallCount() int {
	fake.parseReferenceMutex.RLock()
	defer fake.parseReferenceMutex.RUnlock()
	return len(fake.parseReferenceArgsForCall)
}

func (fake *FakeImpl) ParseReferenceCalls(stub func(string, ...name.Option) (name.Reference, error)) {
	fake.parseReferenceMutex.Lock()
	defer fake.parseReferenceMutex.Unlock()
	fake.ParseReferenceStub = stub
}

func (fake *FakeImpl) ParseReferenceArgsForCall(i int) (string, []name.Option) {
	fake.parseReferenceMutex.RLock()
	defer fake.parseReferenceMutex.RUnlock()
	argsForCall := fake.parseReferenceArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeImpl) ParseReferenceReturns(result1 name.Reference, result2 error) {
	fake.parseReferenceMutex.Lock()
	defer fake.parseReferenceMutex.Unlock()
	fake.ParseReferenceStub = nil
	fake.parseReferenceReturns = struct {
		result1 name.Reference
		result2 error
	}{result1, result2}
}

func (fake *FakeImpl) ParseReferenceReturnsOnCall(i int, result1 name.Reference, result2 error) {
	fake.parseReferenceMutex.Lock()
	defer fake.parseReferenceMutex.Unlock()
	fake.ParseReferenceStub = nil
	if fake.parseReferenceReturnsOnCall == nil {
		fake.parseReferenceReturnsOnCall = make(map[int]struct {
			result1 name.Reference
			result2 error
		})
	}
	fake.parseReferenceReturnsOnCall[i] = struct {
		result1 name.Reference
		result2 error
	}{result1, result2}
}

func (fake *FakeImpl) PayloadBytes(arg1 string) ([]byte, error) {
	fake.payloadBytesMutex.Lock()
	ret, specificReturn := fake.payloadBytesReturnsOnCall[len(fake.payloadBytesArgsForCall)]
	fake.payloadBytesArgsForCall = append(fake.payloadBytesArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.PayloadBytesStub
	fakeReturns := fake.payloadBytesReturns
	fake.recordInvocation("PayloadBytes", []interface{}{arg1})
	fake.payloadBytesMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeImpl) PayloadBytesCallCount() int {
	fake.payloadBytesMutex.RLock()
	defer fake.payloadBytesMutex.RUnlock()
	return len(fake.payloadBytesArgsForCall)
}

func (fake *FakeImpl) PayloadBytesCalls(stub func(string) ([]byte, error)) {
	fake.payloadBytesMutex.Lock()
	defer fake.payloadBytesMutex.Unlock()
	fake.PayloadBytesStub = stub
}

func (fake *FakeImpl) PayloadBytesArgsForCall(i int) string {
	fake.payloadBytesMutex.RLock()
	defer fake.payloadBytesMutex.RUnlock()
	argsForCall := fake.payloadBytesArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeImpl) PayloadBytesReturns(result1 []byte, result2 error) {
	fake.payloadBytesMutex.Lock()
	defer fake.payloadBytesMutex.Unlock()
	fake.PayloadBytesStub = nil
	fake.payloadBytesReturns = struct {
		result1 []byte
		result2 error
	}{result1, result2}
}

func (fake *FakeImpl) PayloadBytesReturnsOnCall(i int, result1 []byte, result2 error) {
	fake.payloadBytesMutex.Lock()
	defer fake.payloadBytesMutex.Unlock()
	fake.PayloadBytesStub = nil
	if fake.payloadBytesReturnsOnCall == nil {
		fake.payloadBytesReturnsOnCall = make(map[int]struct {
			result1 []byte
			result2 error
		})
	}
	fake.payloadBytesReturnsOnCall[i] = struct {
		result1 []byte
		result2 error
	}{result1, result2}
}

func (fake *FakeImpl) Setenv(arg1 string, arg2 string) error {
	fake.setenvMutex.Lock()
	ret, specificReturn := fake.setenvReturnsOnCall[len(fake.setenvArgsForCall)]
	fake.setenvArgsForCall = append(fake.setenvArgsForCall, struct {
		arg1 string
		arg2 string
	}{arg1, arg2})
	stub := fake.SetenvStub
	fakeReturns := fake.setenvReturns
	fake.recordInvocation("Setenv", []interface{}{arg1, arg2})
	fake.setenvMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeImpl) SetenvCallCount() int {
	fake.setenvMutex.RLock()
	defer fake.setenvMutex.RUnlock()
	return len(fake.setenvArgsForCall)
}

func (fake *FakeImpl) SetenvCalls(stub func(string, string) error) {
	fake.setenvMutex.Lock()
	defer fake.setenvMutex.Unlock()
	fake.SetenvStub = stub
}

func (fake *FakeImpl) SetenvArgsForCall(i int) (string, string) {
	fake.setenvMutex.RLock()
	defer fake.setenvMutex.RUnlock()
	argsForCall := fake.setenvArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeImpl) SetenvReturns(result1 error) {
	fake.setenvMutex.Lock()
	defer fake.setenvMutex.Unlock()
	fake.SetenvStub = nil
	fake.setenvReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeImpl) SetenvReturnsOnCall(i int, result1 error) {
	fake.setenvMutex.Lock()
	defer fake.setenvMutex.Unlock()
	fake.SetenvStub = nil
	if fake.setenvReturnsOnCall == nil {
		fake.setenvReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.setenvReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeImpl) SignFileInternal(arg1 options.RootOptions, arg2 options.KeyOpts, arg3 string, arg4 bool, arg5 string, arg6 string, arg7 bool) error {
	fake.signFileInternalMutex.Lock()
	ret, specificReturn := fake.signFileInternalReturnsOnCall[len(fake.signFileInternalArgsForCall)]
	fake.signFileInternalArgsForCall = append(fake.signFileInternalArgsForCall, struct {
		arg1 options.RootOptions
		arg2 options.KeyOpts
		arg3 string
		arg4 bool
		arg5 string
		arg6 string
		arg7 bool
	}{arg1, arg2, arg3, arg4, arg5, arg6, arg7})
	stub := fake.SignFileInternalStub
	fakeReturns := fake.signFileInternalReturns
	fake.recordInvocation("SignFileInternal", []interface{}{arg1, arg2, arg3, arg4, arg5, arg6, arg7})
	fake.signFileInternalMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4, arg5, arg6, arg7)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeImpl) SignFileInternalCallCount() int {
	fake.signFileInternalMutex.RLock()
	defer fake.signFileInternalMutex.RUnlock()
	return len(fake.signFileInternalArgsForCall)
}

func (fake *FakeImpl) SignFileInternalCalls(stub func(options.RootOptions, options.KeyOpts, string, bool, string, string, bool) error) {
	fake.signFileInternalMutex.Lock()
	defer fake.signFileInternalMutex.Unlock()
	fake.SignFileInternalStub = stub
}

func (fake *FakeImpl) SignFileInternalArgsForCall(i int) (options.RootOptions, options.KeyOpts, string, bool, string, string, bool) {
	fake.signFileInternalMutex.RLock()
	defer fake.signFileInternalMutex.RUnlock()
	argsForCall := fake.signFileInternalArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4, argsForCall.arg5, argsForCall.arg6, argsForCall.arg7
}

func (fake *FakeImpl) SignFileInternalReturns(result1 error) {
	fake.signFileInternalMutex.Lock()
	defer fake.signFileInternalMutex.Unlock()
	fake.SignFileInternalStub = nil
	fake.signFileInternalReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeImpl) SignFileInternalReturnsOnCall(i int, result1 error) {
	fake.signFileInternalMutex.Lock()
	defer fake.signFileInternalMutex.Unlock()
	fake.SignFileInternalStub = nil
	if fake.signFileInternalReturnsOnCall == nil {
		fake.signFileInternalReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.signFileInternalReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeImpl) SignImageInternal(arg1 options.RootOptions, arg2 options.KeyOpts, arg3 options.SignOptions, arg4 []string) error {
	var arg4Copy []string
	if arg4 != nil {
		arg4Copy = make([]string, len(arg4))
		copy(arg4Copy, arg4)
	}
	fake.signImageInternalMutex.Lock()
	ret, specificReturn := fake.signImageInternalReturnsOnCall[len(fake.signImageInternalArgsForCall)]
	fake.signImageInternalArgsForCall = append(fake.signImageInternalArgsForCall, struct {
		arg1 options.RootOptions
		arg2 options.KeyOpts
		arg3 options.SignOptions
		arg4 []string
	}{arg1, arg2, arg3, arg4Copy})
	stub := fake.SignImageInternalStub
	fakeReturns := fake.signImageInternalReturns
	fake.recordInvocation("SignImageInternal", []interface{}{arg1, arg2, arg3, arg4Copy})
	fake.signImageInternalMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeImpl) SignImageInternalCallCount() int {
	fake.signImageInternalMutex.RLock()
	defer fake.signImageInternalMutex.RUnlock()
	return len(fake.signImageInternalArgsForCall)
}

func (fake *FakeImpl) SignImageInternalCalls(stub func(options.RootOptions, options.KeyOpts, options.SignOptions, []string) error) {
	fake.signImageInternalMutex.Lock()
	defer fake.signImageInternalMutex.Unlock()
	fake.SignImageInternalStub = stub
}

func (fake *FakeImpl) SignImageInternalArgsForCall(i int) (options.RootOptions, options.KeyOpts, options.SignOptions, []string) {
	fake.signImageInternalMutex.RLock()
	defer fake.signImageInternalMutex.RUnlock()
	argsForCall := fake.signImageInternalArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeImpl) SignImageInternalReturns(result1 error) {
	fake.signImageInternalMutex.Lock()
	defer fake.signImageInternalMutex.Unlock()
	fake.SignImageInternalStub = nil
	fake.signImageInternalReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeImpl) SignImageInternalReturnsOnCall(i int, result1 error) {
	fake.signImageInternalMutex.Lock()
	defer fake.signImageInternalMutex.Unlock()
	fake.SignImageInternalStub = nil
	if fake.signImageInternalReturnsOnCall == nil {
		fake.signImageInternalReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.signImageInternalReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeImpl) TokenFromProviders(arg1 context.Context, arg2 *logrus.Logger) (string, error) {
	fake.tokenFromProvidersMutex.Lock()
	ret, specificReturn := fake.tokenFromProvidersReturnsOnCall[len(fake.tokenFromProvidersArgsForCall)]
	fake.tokenFromProvidersArgsForCall = append(fake.tokenFromProvidersArgsForCall, struct {
		arg1 context.Context
		arg2 *logrus.Logger
	}{arg1, arg2})
	stub := fake.TokenFromProvidersStub
	fakeReturns := fake.tokenFromProvidersReturns
	fake.recordInvocation("TokenFromProviders", []interface{}{arg1, arg2})
	fake.tokenFromProvidersMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeImpl) TokenFromProvidersCallCount() int {
	fake.tokenFromProvidersMutex.RLock()
	defer fake.tokenFromProvidersMutex.RUnlock()
	return len(fake.tokenFromProvidersArgsForCall)
}

func (fake *FakeImpl) TokenFromProvidersCalls(stub func(context.Context, *logrus.Logger) (string, error)) {
	fake.tokenFromProvidersMutex.Lock()
	defer fake.tokenFromProvidersMutex.Unlock()
	fake.TokenFromProvidersStub = stub
}

func (fake *FakeImpl) TokenFromProvidersArgsForCall(i int) (context.Context, *logrus.Logger) {
	fake.tokenFromProvidersMutex.RLock()
	defer fake.tokenFromProvidersMutex.RUnlock()
	argsForCall := fake.tokenFromProvidersArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeImpl) TokenFromProvidersReturns(result1 string, result2 error) {
	fake.tokenFromProvidersMutex.Lock()
	defer fake.tokenFromProvidersMutex.Unlock()
	fake.TokenFromProvidersStub = nil
	fake.tokenFromProvidersReturns = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeImpl) TokenFromProvidersReturnsOnCall(i int, result1 string, result2 error) {
	fake.tokenFromProvidersMutex.Lock()
	defer fake.tokenFromProvidersMutex.Unlock()
	fake.TokenFromProvidersStub = nil
	if fake.tokenFromProvidersReturnsOnCall == nil {
		fake.tokenFromProvidersReturnsOnCall = make(map[int]struct {
			result1 string
			result2 error
		})
	}
	fake.tokenFromProvidersReturnsOnCall[i] = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeImpl) VerifyFileInternal(arg1 context.Context, arg2 options.KeyOpts, arg3 options.CertVerifyOptions, arg4 string, arg5 string) error {
	fake.verifyFileInternalMutex.Lock()
	ret, specificReturn := fake.verifyFileInternalReturnsOnCall[len(fake.verifyFileInternalArgsForCall)]
	fake.verifyFileInternalArgsForCall = append(fake.verifyFileInternalArgsForCall, struct {
		arg1 context.Context
		arg2 options.KeyOpts
		arg3 options.CertVerifyOptions
		arg4 string
		arg5 string
	}{arg1, arg2, arg3, arg4, arg5})
	stub := fake.VerifyFileInternalStub
	fakeReturns := fake.verifyFileInternalReturns
	fake.recordInvocation("VerifyFileInternal", []interface{}{arg1, arg2, arg3, arg4, arg5})
	fake.verifyFileInternalMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4, arg5)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeImpl) VerifyFileInternalCallCount() int {
	fake.verifyFileInternalMutex.RLock()
	defer fake.verifyFileInternalMutex.RUnlock()
	return len(fake.verifyFileInternalArgsForCall)
}

func (fake *FakeImpl) VerifyFileInternalCalls(stub func(context.Context, options.KeyOpts, options.CertVerifyOptions, string, string) error) {
	fake.verifyFileInternalMutex.Lock()
	defer fake.verifyFileInternalMutex.Unlock()
	fake.VerifyFileInternalStub = stub
}

func (fake *FakeImpl) VerifyFileInternalArgsForCall(i int) (context.Context, options.KeyOpts, options.CertVerifyOptions, string, string) {
	fake.verifyFileInternalMutex.RLock()
	defer fake.verifyFileInternalMutex.RUnlock()
	argsForCall := fake.verifyFileInternalArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4, argsForCall.arg5
}

func (fake *FakeImpl) VerifyFileInternalReturns(result1 error) {
	fake.verifyFileInternalMutex.Lock()
	defer fake.verifyFileInternalMutex.Unlock()
	fake.VerifyFileInternalStub = nil
	fake.verifyFileInternalReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeImpl) VerifyFileInternalReturnsOnCall(i int, result1 error) {
	fake.verifyFileInternalMutex.Lock()
	defer fake.verifyFileInternalMutex.Unlock()
	fake.VerifyFileInternalStub = nil
	if fake.verifyFileInternalReturnsOnCall == nil {
		fake.verifyFileInternalReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.verifyFileInternalReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeImpl) VerifyImageInternal(arg1 context.Context, arg2 options.CertVerifyOptions, arg3 string, arg4 []string, arg5 bool) (*sign.SignedObject, error) {
	var arg4Copy []string
	if arg4 != nil {
		arg4Copy = make([]string, len(arg4))
		copy(arg4Copy, arg4)
	}
	fake.verifyImageInternalMutex.Lock()
	ret, specificReturn := fake.verifyImageInternalReturnsOnCall[len(fake.verifyImageInternalArgsForCall)]
	fake.verifyImageInternalArgsForCall = append(fake.verifyImageInternalArgsForCall, struct {
		arg1 context.Context
		arg2 options.CertVerifyOptions
		arg3 string
		arg4 []string
		arg5 bool
	}{arg1, arg2, arg3, arg4Copy, arg5})
	stub := fake.VerifyImageInternalStub
	fakeReturns := fake.verifyImageInternalReturns
	fake.recordInvocation("VerifyImageInternal", []interface{}{arg1, arg2, arg3, arg4Copy, arg5})
	fake.verifyImageInternalMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4, arg5)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeImpl) VerifyImageInternalCallCount() int {
	fake.verifyImageInternalMutex.RLock()
	defer fake.verifyImageInternalMutex.RUnlock()
	return len(fake.verifyImageInternalArgsForCall)
}

func (fake *FakeImpl) VerifyImageInternalCalls(stub func(context.Context, options.CertVerifyOptions, string, []string, bool) (*sign.SignedObject, error)) {
	fake.verifyImageInternalMutex.Lock()
	defer fake.verifyImageInternalMutex.Unlock()
	fake.VerifyImageInternalStub = stub
}

func (fake *FakeImpl) VerifyImageInternalArgsForCall(i int) (context.Context, options.CertVerifyOptions, string, []string, bool) {
	fake.verifyImageInternalMutex.RLock()
	defer fake.verifyImageInternalMutex.RUnlock()
	argsForCall := fake.verifyImageInternalArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4, argsForCall.arg5
}

func (fake *FakeImpl) VerifyImageInternalReturns(result1 *sign.SignedObject, result2 error) {
	fake.verifyImageInternalMutex.Lock()
	defer fake.verifyImageInternalMutex.Unlock()
	fake.VerifyImageInternalStub = nil
	fake.verifyImageInternalReturns = struct {
		result1 *sign.SignedObject
		result2 error
	}{result1, result2}
}

func (fake *FakeImpl) VerifyImageInternalReturnsOnCall(i int, result1 *sign.SignedObject, result2 error) {
	fake.verifyImageInternalMutex.Lock()
	defer fake.verifyImageInternalMutex.Unlock()
	fake.VerifyImageInternalStub = nil
	if fake.verifyImageInternalReturnsOnCall == nil {
		fake.verifyImageInternalReturnsOnCall = make(map[int]struct {
			result1 *sign.SignedObject
			result2 error
		})
	}
	fake.verifyImageInternalReturnsOnCall[i] = struct {
		result1 *sign.SignedObject
		result2 error
	}{result1, result2}
}

func (fake *FakeImpl) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeImpl) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}
