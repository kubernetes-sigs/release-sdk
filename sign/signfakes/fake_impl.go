/*
Copyright The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by counterfeiter. DO NOT EDIT.
package signfakes

import (
	"context"
	"net/http"
	"sync"

	"github.com/google/go-containerregistry/pkg/authn"
	"github.com/google/go-containerregistry/pkg/crane"
	"github.com/google/go-containerregistry/pkg/name"
	"github.com/sigstore/cosign/cmd/cosign/cli/options"
	"github.com/sigstore/rekor/pkg/generated/client"
	"github.com/sirupsen/logrus"
	"sigs.k8s.io/release-sdk/sign"
)

type FakeImpl struct {
	DigestStub        func(string, ...crane.Option) (string, error)
	digestMutex       sync.RWMutex
	digestArgsForCall []struct {
		arg1 string
		arg2 []crane.Option
	}
	digestReturns struct {
		result1 string
		result2 error
	}
	digestReturnsOnCall map[int]struct {
		result1 string
		result2 error
	}
	EnvDefaultStub        func(string, string) string
	envDefaultMutex       sync.RWMutex
	envDefaultArgsForCall []struct {
		arg1 string
		arg2 string
	}
	envDefaultReturns struct {
		result1 string
	}
	envDefaultReturnsOnCall map[int]struct {
		result1 string
	}
	FileExistsStub        func(string) bool
	fileExistsMutex       sync.RWMutex
	fileExistsArgsForCall []struct {
		arg1 string
	}
	fileExistsReturns struct {
		result1 bool
	}
	fileExistsReturnsOnCall map[int]struct {
		result1 bool
	}
	FindTLogEntriesByPayloadStub        func(context.Context, *client.Rekor, []byte) ([]string, error)
	findTLogEntriesByPayloadMutex       sync.RWMutex
	findTLogEntriesByPayloadArgsForCall []struct {
		arg1 context.Context
		arg2 *client.Rekor
		arg3 []byte
	}
	findTLogEntriesByPayloadReturns struct {
		result1 []string
		result2 error
	}
	findTLogEntriesByPayloadReturnsOnCall map[int]struct {
		result1 []string
		result2 error
	}
	ImagesSignedStub        func(context.Context, *sign.Signer, string) (*sync.Map, error)
	imagesSignedMutex       sync.RWMutex
	imagesSignedArgsForCall []struct {
		arg1 context.Context
		arg2 *sign.Signer
		arg3 string
	}
	imagesSignedReturns struct {
		result1 *sync.Map
		result2 error
	}
	imagesSignedReturnsOnCall map[int]struct {
		result1 *sync.Map
		result2 error
	}
	NewRekorClientStub        func(string) (*client.Rekor, error)
	newRekorClientMutex       sync.RWMutex
	newRekorClientArgsForCall []struct {
		arg1 string
	}
	newRekorClientReturns struct {
		result1 *client.Rekor
		result2 error
	}
	newRekorClientReturnsOnCall map[int]struct {
		result1 *client.Rekor
		result2 error
	}
	NewWithContextStub        func(context.Context, name.Registry, authn.Authenticator, http.RoundTripper, []string) (http.RoundTripper, error)
	newWithContextMutex       sync.RWMutex
	newWithContextArgsForCall []struct {
		arg1 context.Context
		arg2 name.Registry
		arg3 authn.Authenticator
		arg4 http.RoundTripper
		arg5 []string
	}
	newWithContextReturns struct {
		result1 http.RoundTripper
		result2 error
	}
	newWithContextReturnsOnCall map[int]struct {
		result1 http.RoundTripper
		result2 error
	}
	ParseReferenceStub        func(string, ...name.Option) (name.Reference, error)
	parseReferenceMutex       sync.RWMutex
	parseReferenceArgsForCall []struct {
		arg1 string
		arg2 []name.Option
	}
	parseReferenceReturns struct {
		result1 name.Reference
		result2 error
	}
	parseReferenceReturnsOnCall map[int]struct {
		result1 name.Reference
		result2 error
	}
	PayloadBytesStub        func(string) ([]byte, error)
	payloadBytesMutex       sync.RWMutex
	payloadBytesArgsForCall []struct {
		arg1 string
	}
	payloadBytesReturns struct {
		result1 []byte
		result2 error
	}
	payloadBytesReturnsOnCall map[int]struct {
		result1 []byte
		result2 error
	}
	SetenvStub        func(string, string) error
	setenvMutex       sync.RWMutex
	setenvArgsForCall []struct {
		arg1 string
		arg2 string
	}
	setenvReturns struct {
		result1 error
	}
	setenvReturnsOnCall map[int]struct {
		result1 error
	}
	SignFileInternalStub        func(options.RootOptions, options.KeyOpts, options.RegistryOptions, string, bool, string, string) error
	signFileInternalMutex       sync.RWMutex
	signFileInternalArgsForCall []struct {
		arg1 options.RootOptions
		arg2 options.KeyOpts
		arg3 options.RegistryOptions
		arg4 string
		arg5 bool
		arg6 string
		arg7 string
	}
	signFileInternalReturns struct {
		result1 error
	}
	signFileInternalReturnsOnCall map[int]struct {
		result1 error
	}
	SignImageInternalStub        func(options.RootOptions, options.KeyOpts, options.RegistryOptions, map[string]interface{}, []string, string, bool, string, string, string, bool, bool, string, bool) error
	signImageInternalMutex       sync.RWMutex
	signImageInternalArgsForCall []struct {
		arg1  options.RootOptions
		arg2  options.KeyOpts
		arg3  options.RegistryOptions
		arg4  map[string]interface{}
		arg5  []string
		arg6  string
		arg7  bool
		arg8  string
		arg9  string
		arg10 string
		arg11 bool
		arg12 bool
		arg13 string
		arg14 bool
	}
	signImageInternalReturns struct {
		result1 error
	}
	signImageInternalReturnsOnCall map[int]struct {
		result1 error
	}
	TokenFromProvidersStub        func(context.Context, *logrus.Logger) (string, error)
	tokenFromProvidersMutex       sync.RWMutex
	tokenFromProvidersArgsForCall []struct {
		arg1 context.Context
		arg2 *logrus.Logger
	}
	tokenFromProvidersReturns struct {
		result1 string
		result2 error
	}
	tokenFromProvidersReturnsOnCall map[int]struct {
		result1 string
		result2 error
	}
	VerifyFileInternalStub        func(context.Context, options.KeyOpts, string, string, string) error
	verifyFileInternalMutex       sync.RWMutex
	verifyFileInternalArgsForCall []struct {
		arg1 context.Context
		arg2 options.KeyOpts
		arg3 string
		arg4 string
		arg5 string
	}
	verifyFileInternalReturns struct {
		result1 error
	}
	verifyFileInternalReturnsOnCall map[int]struct {
		result1 error
	}
	VerifyImageInternalStub        func(context.Context, string, []string) (*sign.SignedObject, error)
	verifyImageInternalMutex       sync.RWMutex
	verifyImageInternalArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 []string
	}
	verifyImageInternalReturns struct {
		result1 *sign.SignedObject
		result2 error
	}
	verifyImageInternalReturnsOnCall map[int]struct {
		result1 *sign.SignedObject
		result2 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeImpl) Digest(arg1 string, arg2 ...crane.Option) (string, error) {
	fake.digestMutex.Lock()
	ret, specificReturn := fake.digestReturnsOnCall[len(fake.digestArgsForCall)]
	fake.digestArgsForCall = append(fake.digestArgsForCall, struct {
		arg1 string
		arg2 []crane.Option
	}{arg1, arg2})
	stub := fake.DigestStub
	fakeReturns := fake.digestReturns
	fake.recordInvocation("Digest", []interface{}{arg1, arg2})
	fake.digestMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeImpl) DigestCallCount() int {
	fake.digestMutex.RLock()
	defer fake.digestMutex.RUnlock()
	return len(fake.digestArgsForCall)
}

func (fake *FakeImpl) DigestCalls(stub func(string, ...crane.Option) (string, error)) {
	fake.digestMutex.Lock()
	defer fake.digestMutex.Unlock()
	fake.DigestStub = stub
}

func (fake *FakeImpl) DigestArgsForCall(i int) (string, []crane.Option) {
	fake.digestMutex.RLock()
	defer fake.digestMutex.RUnlock()
	argsForCall := fake.digestArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeImpl) DigestReturns(result1 string, result2 error) {
	fake.digestMutex.Lock()
	defer fake.digestMutex.Unlock()
	fake.DigestStub = nil
	fake.digestReturns = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeImpl) DigestReturnsOnCall(i int, result1 string, result2 error) {
	fake.digestMutex.Lock()
	defer fake.digestMutex.Unlock()
	fake.DigestStub = nil
	if fake.digestReturnsOnCall == nil {
		fake.digestReturnsOnCall = make(map[int]struct {
			result1 string
			result2 error
		})
	}
	fake.digestReturnsOnCall[i] = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeImpl) EnvDefault(arg1 string, arg2 string) string {
	fake.envDefaultMutex.Lock()
	ret, specificReturn := fake.envDefaultReturnsOnCall[len(fake.envDefaultArgsForCall)]
	fake.envDefaultArgsForCall = append(fake.envDefaultArgsForCall, struct {
		arg1 string
		arg2 string
	}{arg1, arg2})
	stub := fake.EnvDefaultStub
	fakeReturns := fake.envDefaultReturns
	fake.recordInvocation("EnvDefault", []interface{}{arg1, arg2})
	fake.envDefaultMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeImpl) EnvDefaultCallCount() int {
	fake.envDefaultMutex.RLock()
	defer fake.envDefaultMutex.RUnlock()
	return len(fake.envDefaultArgsForCall)
}

func (fake *FakeImpl) EnvDefaultCalls(stub func(string, string) string) {
	fake.envDefaultMutex.Lock()
	defer fake.envDefaultMutex.Unlock()
	fake.EnvDefaultStub = stub
}

func (fake *FakeImpl) EnvDefaultArgsForCall(i int) (string, string) {
	fake.envDefaultMutex.RLock()
	defer fake.envDefaultMutex.RUnlock()
	argsForCall := fake.envDefaultArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeImpl) EnvDefaultReturns(result1 string) {
	fake.envDefaultMutex.Lock()
	defer fake.envDefaultMutex.Unlock()
	fake.EnvDefaultStub = nil
	fake.envDefaultReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeImpl) EnvDefaultReturnsOnCall(i int, result1 string) {
	fake.envDefaultMutex.Lock()
	defer fake.envDefaultMutex.Unlock()
	fake.EnvDefaultStub = nil
	if fake.envDefaultReturnsOnCall == nil {
		fake.envDefaultReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.envDefaultReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeImpl) FileExists(arg1 string) bool {
	fake.fileExistsMutex.Lock()
	ret, specificReturn := fake.fileExistsReturnsOnCall[len(fake.fileExistsArgsForCall)]
	fake.fileExistsArgsForCall = append(fake.fileExistsArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.FileExistsStub
	fakeReturns := fake.fileExistsReturns
	fake.recordInvocation("FileExists", []interface{}{arg1})
	fake.fileExistsMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeImpl) FileExistsCallCount() int {
	fake.fileExistsMutex.RLock()
	defer fake.fileExistsMutex.RUnlock()
	return len(fake.fileExistsArgsForCall)
}

func (fake *FakeImpl) FileExistsCalls(stub func(string) bool) {
	fake.fileExistsMutex.Lock()
	defer fake.fileExistsMutex.Unlock()
	fake.FileExistsStub = stub
}

func (fake *FakeImpl) FileExistsArgsForCall(i int) string {
	fake.fileExistsMutex.RLock()
	defer fake.fileExistsMutex.RUnlock()
	argsForCall := fake.fileExistsArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeImpl) FileExistsReturns(result1 bool) {
	fake.fileExistsMutex.Lock()
	defer fake.fileExistsMutex.Unlock()
	fake.FileExistsStub = nil
	fake.fileExistsReturns = struct {
		result1 bool
	}{result1}
}

func (fake *FakeImpl) FileExistsReturnsOnCall(i int, result1 bool) {
	fake.fileExistsMutex.Lock()
	defer fake.fileExistsMutex.Unlock()
	fake.FileExistsStub = nil
	if fake.fileExistsReturnsOnCall == nil {
		fake.fileExistsReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.fileExistsReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *FakeImpl) FindTLogEntriesByPayload(arg1 context.Context, arg2 *client.Rekor, arg3 []byte) ([]string, error) {
	var arg3Copy []byte
	if arg3 != nil {
		arg3Copy = make([]byte, len(arg3))
		copy(arg3Copy, arg3)
	}
	fake.findTLogEntriesByPayloadMutex.Lock()
	ret, specificReturn := fake.findTLogEntriesByPayloadReturnsOnCall[len(fake.findTLogEntriesByPayloadArgsForCall)]
	fake.findTLogEntriesByPayloadArgsForCall = append(fake.findTLogEntriesByPayloadArgsForCall, struct {
		arg1 context.Context
		arg2 *client.Rekor
		arg3 []byte
	}{arg1, arg2, arg3Copy})
	stub := fake.FindTLogEntriesByPayloadStub
	fakeReturns := fake.findTLogEntriesByPayloadReturns
	fake.recordInvocation("FindTLogEntriesByPayload", []interface{}{arg1, arg2, arg3Copy})
	fake.findTLogEntriesByPayloadMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeImpl) FindTLogEntriesByPayloadCallCount() int {
	fake.findTLogEntriesByPayloadMutex.RLock()
	defer fake.findTLogEntriesByPayloadMutex.RUnlock()
	return len(fake.findTLogEntriesByPayloadArgsForCall)
}

func (fake *FakeImpl) FindTLogEntriesByPayloadCalls(stub func(context.Context, *client.Rekor, []byte) ([]string, error)) {
	fake.findTLogEntriesByPayloadMutex.Lock()
	defer fake.findTLogEntriesByPayloadMutex.Unlock()
	fake.FindTLogEntriesByPayloadStub = stub
}

func (fake *FakeImpl) FindTLogEntriesByPayloadArgsForCall(i int) (context.Context, *client.Rekor, []byte) {
	fake.findTLogEntriesByPayloadMutex.RLock()
	defer fake.findTLogEntriesByPayloadMutex.RUnlock()
	argsForCall := fake.findTLogEntriesByPayloadArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeImpl) FindTLogEntriesByPayloadReturns(result1 []string, result2 error) {
	fake.findTLogEntriesByPayloadMutex.Lock()
	defer fake.findTLogEntriesByPayloadMutex.Unlock()
	fake.FindTLogEntriesByPayloadStub = nil
	fake.findTLogEntriesByPayloadReturns = struct {
		result1 []string
		result2 error
	}{result1, result2}
}

func (fake *FakeImpl) FindTLogEntriesByPayloadReturnsOnCall(i int, result1 []string, result2 error) {
	fake.findTLogEntriesByPayloadMutex.Lock()
	defer fake.findTLogEntriesByPayloadMutex.Unlock()
	fake.FindTLogEntriesByPayloadStub = nil
	if fake.findTLogEntriesByPayloadReturnsOnCall == nil {
		fake.findTLogEntriesByPayloadReturnsOnCall = make(map[int]struct {
			result1 []string
			result2 error
		})
	}
	fake.findTLogEntriesByPayloadReturnsOnCall[i] = struct {
		result1 []string
		result2 error
	}{result1, result2}
}

func (fake *FakeImpl) ImagesSigned(arg1 context.Context, arg2 *sign.Signer, arg3 string) (*sync.Map, error) {
	fake.imagesSignedMutex.Lock()
	ret, specificReturn := fake.imagesSignedReturnsOnCall[len(fake.imagesSignedArgsForCall)]
	fake.imagesSignedArgsForCall = append(fake.imagesSignedArgsForCall, struct {
		arg1 context.Context
		arg2 *sign.Signer
		arg3 string
	}{arg1, arg2, arg3})
	stub := fake.ImagesSignedStub
	fakeReturns := fake.imagesSignedReturns
	fake.recordInvocation("ImagesSigned", []interface{}{arg1, arg2, arg3})
	fake.imagesSignedMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeImpl) ImagesSignedCallCount() int {
	fake.imagesSignedMutex.RLock()
	defer fake.imagesSignedMutex.RUnlock()
	return len(fake.imagesSignedArgsForCall)
}

func (fake *FakeImpl) ImagesSignedCalls(stub func(context.Context, *sign.Signer, string) (*sync.Map, error)) {
	fake.imagesSignedMutex.Lock()
	defer fake.imagesSignedMutex.Unlock()
	fake.ImagesSignedStub = stub
}

func (fake *FakeImpl) ImagesSignedArgsForCall(i int) (context.Context, *sign.Signer, string) {
	fake.imagesSignedMutex.RLock()
	defer fake.imagesSignedMutex.RUnlock()
	argsForCall := fake.imagesSignedArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeImpl) ImagesSignedReturns(result1 *sync.Map, result2 error) {
	fake.imagesSignedMutex.Lock()
	defer fake.imagesSignedMutex.Unlock()
	fake.ImagesSignedStub = nil
	fake.imagesSignedReturns = struct {
		result1 *sync.Map
		result2 error
	}{result1, result2}
}

func (fake *FakeImpl) ImagesSignedReturnsOnCall(i int, result1 *sync.Map, result2 error) {
	fake.imagesSignedMutex.Lock()
	defer fake.imagesSignedMutex.Unlock()
	fake.ImagesSignedStub = nil
	if fake.imagesSignedReturnsOnCall == nil {
		fake.imagesSignedReturnsOnCall = make(map[int]struct {
			result1 *sync.Map
			result2 error
		})
	}
	fake.imagesSignedReturnsOnCall[i] = struct {
		result1 *sync.Map
		result2 error
	}{result1, result2}
}

func (fake *FakeImpl) NewRekorClient(arg1 string) (*client.Rekor, error) {
	fake.newRekorClientMutex.Lock()
	ret, specificReturn := fake.newRekorClientReturnsOnCall[len(fake.newRekorClientArgsForCall)]
	fake.newRekorClientArgsForCall = append(fake.newRekorClientArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.NewRekorClientStub
	fakeReturns := fake.newRekorClientReturns
	fake.recordInvocation("NewRekorClient", []interface{}{arg1})
	fake.newRekorClientMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeImpl) NewRekorClientCallCount() int {
	fake.newRekorClientMutex.RLock()
	defer fake.newRekorClientMutex.RUnlock()
	return len(fake.newRekorClientArgsForCall)
}

func (fake *FakeImpl) NewRekorClientCalls(stub func(string) (*client.Rekor, error)) {
	fake.newRekorClientMutex.Lock()
	defer fake.newRekorClientMutex.Unlock()
	fake.NewRekorClientStub = stub
}

func (fake *FakeImpl) NewRekorClientArgsForCall(i int) string {
	fake.newRekorClientMutex.RLock()
	defer fake.newRekorClientMutex.RUnlock()
	argsForCall := fake.newRekorClientArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeImpl) NewRekorClientReturns(result1 *client.Rekor, result2 error) {
	fake.newRekorClientMutex.Lock()
	defer fake.newRekorClientMutex.Unlock()
	fake.NewRekorClientStub = nil
	fake.newRekorClientReturns = struct {
		result1 *client.Rekor
		result2 error
	}{result1, result2}
}

func (fake *FakeImpl) NewRekorClientReturnsOnCall(i int, result1 *client.Rekor, result2 error) {
	fake.newRekorClientMutex.Lock()
	defer fake.newRekorClientMutex.Unlock()
	fake.NewRekorClientStub = nil
	if fake.newRekorClientReturnsOnCall == nil {
		fake.newRekorClientReturnsOnCall = make(map[int]struct {
			result1 *client.Rekor
			result2 error
		})
	}
	fake.newRekorClientReturnsOnCall[i] = struct {
		result1 *client.Rekor
		result2 error
	}{result1, result2}
}

func (fake *FakeImpl) NewWithContext(arg1 context.Context, arg2 name.Registry, arg3 authn.Authenticator, arg4 http.RoundTripper, arg5 []string) (http.RoundTripper, error) {
	var arg5Copy []string
	if arg5 != nil {
		arg5Copy = make([]string, len(arg5))
		copy(arg5Copy, arg5)
	}
	fake.newWithContextMutex.Lock()
	ret, specificReturn := fake.newWithContextReturnsOnCall[len(fake.newWithContextArgsForCall)]
	fake.newWithContextArgsForCall = append(fake.newWithContextArgsForCall, struct {
		arg1 context.Context
		arg2 name.Registry
		arg3 authn.Authenticator
		arg4 http.RoundTripper
		arg5 []string
	}{arg1, arg2, arg3, arg4, arg5Copy})
	stub := fake.NewWithContextStub
	fakeReturns := fake.newWithContextReturns
	fake.recordInvocation("NewWithContext", []interface{}{arg1, arg2, arg3, arg4, arg5Copy})
	fake.newWithContextMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4, arg5)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeImpl) NewWithContextCallCount() int {
	fake.newWithContextMutex.RLock()
	defer fake.newWithContextMutex.RUnlock()
	return len(fake.newWithContextArgsForCall)
}

func (fake *FakeImpl) NewWithContextCalls(stub func(context.Context, name.Registry, authn.Authenticator, http.RoundTripper, []string) (http.RoundTripper, error)) {
	fake.newWithContextMutex.Lock()
	defer fake.newWithContextMutex.Unlock()
	fake.NewWithContextStub = stub
}

func (fake *FakeImpl) NewWithContextArgsForCall(i int) (context.Context, name.Registry, authn.Authenticator, http.RoundTripper, []string) {
	fake.newWithContextMutex.RLock()
	defer fake.newWithContextMutex.RUnlock()
	argsForCall := fake.newWithContextArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4, argsForCall.arg5
}

func (fake *FakeImpl) NewWithContextReturns(result1 http.RoundTripper, result2 error) {
	fake.newWithContextMutex.Lock()
	defer fake.newWithContextMutex.Unlock()
	fake.NewWithContextStub = nil
	fake.newWithContextReturns = struct {
		result1 http.RoundTripper
		result2 error
	}{result1, result2}
}

func (fake *FakeImpl) NewWithContextReturnsOnCall(i int, result1 http.RoundTripper, result2 error) {
	fake.newWithContextMutex.Lock()
	defer fake.newWithContextMutex.Unlock()
	fake.NewWithContextStub = nil
	if fake.newWithContextReturnsOnCall == nil {
		fake.newWithContextReturnsOnCall = make(map[int]struct {
			result1 http.RoundTripper
			result2 error
		})
	}
	fake.newWithContextReturnsOnCall[i] = struct {
		result1 http.RoundTripper
		result2 error
	}{result1, result2}
}

func (fake *FakeImpl) ParseReference(arg1 string, arg2 ...name.Option) (name.Reference, error) {
	fake.parseReferenceMutex.Lock()
	ret, specificReturn := fake.parseReferenceReturnsOnCall[len(fake.parseReferenceArgsForCall)]
	fake.parseReferenceArgsForCall = append(fake.parseReferenceArgsForCall, struct {
		arg1 string
		arg2 []name.Option
	}{arg1, arg2})
	stub := fake.ParseReferenceStub
	fakeReturns := fake.parseReferenceReturns
	fake.recordInvocation("ParseReference", []interface{}{arg1, arg2})
	fake.parseReferenceMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeImpl) ParseReferenceCallCount() int {
	fake.parseReferenceMutex.RLock()
	defer fake.parseReferenceMutex.RUnlock()
	return len(fake.parseReferenceArgsForCall)
}

func (fake *FakeImpl) ParseReferenceCalls(stub func(string, ...name.Option) (name.Reference, error)) {
	fake.parseReferenceMutex.Lock()
	defer fake.parseReferenceMutex.Unlock()
	fake.ParseReferenceStub = stub
}

func (fake *FakeImpl) ParseReferenceArgsForCall(i int) (string, []name.Option) {
	fake.parseReferenceMutex.RLock()
	defer fake.parseReferenceMutex.RUnlock()
	argsForCall := fake.parseReferenceArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeImpl) ParseReferenceReturns(result1 name.Reference, result2 error) {
	fake.parseReferenceMutex.Lock()
	defer fake.parseReferenceMutex.Unlock()
	fake.ParseReferenceStub = nil
	fake.parseReferenceReturns = struct {
		result1 name.Reference
		result2 error
	}{result1, result2}
}

func (fake *FakeImpl) ParseReferenceReturnsOnCall(i int, result1 name.Reference, result2 error) {
	fake.parseReferenceMutex.Lock()
	defer fake.parseReferenceMutex.Unlock()
	fake.ParseReferenceStub = nil
	if fake.parseReferenceReturnsOnCall == nil {
		fake.parseReferenceReturnsOnCall = make(map[int]struct {
			result1 name.Reference
			result2 error
		})
	}
	fake.parseReferenceReturnsOnCall[i] = struct {
		result1 name.Reference
		result2 error
	}{result1, result2}
}

func (fake *FakeImpl) PayloadBytes(arg1 string) ([]byte, error) {
	fake.payloadBytesMutex.Lock()
	ret, specificReturn := fake.payloadBytesReturnsOnCall[len(fake.payloadBytesArgsForCall)]
	fake.payloadBytesArgsForCall = append(fake.payloadBytesArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.PayloadBytesStub
	fakeReturns := fake.payloadBytesReturns
	fake.recordInvocation("PayloadBytes", []interface{}{arg1})
	fake.payloadBytesMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeImpl) PayloadBytesCallCount() int {
	fake.payloadBytesMutex.RLock()
	defer fake.payloadBytesMutex.RUnlock()
	return len(fake.payloadBytesArgsForCall)
}

func (fake *FakeImpl) PayloadBytesCalls(stub func(string) ([]byte, error)) {
	fake.payloadBytesMutex.Lock()
	defer fake.payloadBytesMutex.Unlock()
	fake.PayloadBytesStub = stub
}

func (fake *FakeImpl) PayloadBytesArgsForCall(i int) string {
	fake.payloadBytesMutex.RLock()
	defer fake.payloadBytesMutex.RUnlock()
	argsForCall := fake.payloadBytesArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeImpl) PayloadBytesReturns(result1 []byte, result2 error) {
	fake.payloadBytesMutex.Lock()
	defer fake.payloadBytesMutex.Unlock()
	fake.PayloadBytesStub = nil
	fake.payloadBytesReturns = struct {
		result1 []byte
		result2 error
	}{result1, result2}
}

func (fake *FakeImpl) PayloadBytesReturnsOnCall(i int, result1 []byte, result2 error) {
	fake.payloadBytesMutex.Lock()
	defer fake.payloadBytesMutex.Unlock()
	fake.PayloadBytesStub = nil
	if fake.payloadBytesReturnsOnCall == nil {
		fake.payloadBytesReturnsOnCall = make(map[int]struct {
			result1 []byte
			result2 error
		})
	}
	fake.payloadBytesReturnsOnCall[i] = struct {
		result1 []byte
		result2 error
	}{result1, result2}
}

func (fake *FakeImpl) Setenv(arg1 string, arg2 string) error {
	fake.setenvMutex.Lock()
	ret, specificReturn := fake.setenvReturnsOnCall[len(fake.setenvArgsForCall)]
	fake.setenvArgsForCall = append(fake.setenvArgsForCall, struct {
		arg1 string
		arg2 string
	}{arg1, arg2})
	stub := fake.SetenvStub
	fakeReturns := fake.setenvReturns
	fake.recordInvocation("Setenv", []interface{}{arg1, arg2})
	fake.setenvMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeImpl) SetenvCallCount() int {
	fake.setenvMutex.RLock()
	defer fake.setenvMutex.RUnlock()
	return len(fake.setenvArgsForCall)
}

func (fake *FakeImpl) SetenvCalls(stub func(string, string) error) {
	fake.setenvMutex.Lock()
	defer fake.setenvMutex.Unlock()
	fake.SetenvStub = stub
}

func (fake *FakeImpl) SetenvArgsForCall(i int) (string, string) {
	fake.setenvMutex.RLock()
	defer fake.setenvMutex.RUnlock()
	argsForCall := fake.setenvArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeImpl) SetenvReturns(result1 error) {
	fake.setenvMutex.Lock()
	defer fake.setenvMutex.Unlock()
	fake.SetenvStub = nil
	fake.setenvReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeImpl) SetenvReturnsOnCall(i int, result1 error) {
	fake.setenvMutex.Lock()
	defer fake.setenvMutex.Unlock()
	fake.SetenvStub = nil
	if fake.setenvReturnsOnCall == nil {
		fake.setenvReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.setenvReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeImpl) SignFileInternal(arg1 options.RootOptions, arg2 options.KeyOpts, arg3 options.RegistryOptions, arg4 string, arg5 bool, arg6 string, arg7 string) error {
	fake.signFileInternalMutex.Lock()
	ret, specificReturn := fake.signFileInternalReturnsOnCall[len(fake.signFileInternalArgsForCall)]
	fake.signFileInternalArgsForCall = append(fake.signFileInternalArgsForCall, struct {
		arg1 options.RootOptions
		arg2 options.KeyOpts
		arg3 options.RegistryOptions
		arg4 string
		arg5 bool
		arg6 string
		arg7 string
	}{arg1, arg2, arg3, arg4, arg5, arg6, arg7})
	stub := fake.SignFileInternalStub
	fakeReturns := fake.signFileInternalReturns
	fake.recordInvocation("SignFileInternal", []interface{}{arg1, arg2, arg3, arg4, arg5, arg6, arg7})
	fake.signFileInternalMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4, arg5, arg6, arg7)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeImpl) SignFileInternalCallCount() int {
	fake.signFileInternalMutex.RLock()
	defer fake.signFileInternalMutex.RUnlock()
	return len(fake.signFileInternalArgsForCall)
}

func (fake *FakeImpl) SignFileInternalCalls(stub func(options.RootOptions, options.KeyOpts, options.RegistryOptions, string, bool, string, string) error) {
	fake.signFileInternalMutex.Lock()
	defer fake.signFileInternalMutex.Unlock()
	fake.SignFileInternalStub = stub
}

func (fake *FakeImpl) SignFileInternalArgsForCall(i int) (options.RootOptions, options.KeyOpts, options.RegistryOptions, string, bool, string, string) {
	fake.signFileInternalMutex.RLock()
	defer fake.signFileInternalMutex.RUnlock()
	argsForCall := fake.signFileInternalArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4, argsForCall.arg5, argsForCall.arg6, argsForCall.arg7
}

func (fake *FakeImpl) SignFileInternalReturns(result1 error) {
	fake.signFileInternalMutex.Lock()
	defer fake.signFileInternalMutex.Unlock()
	fake.SignFileInternalStub = nil
	fake.signFileInternalReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeImpl) SignFileInternalReturnsOnCall(i int, result1 error) {
	fake.signFileInternalMutex.Lock()
	defer fake.signFileInternalMutex.Unlock()
	fake.SignFileInternalStub = nil
	if fake.signFileInternalReturnsOnCall == nil {
		fake.signFileInternalReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.signFileInternalReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeImpl) SignImageInternal(arg1 options.RootOptions, arg2 options.KeyOpts, arg3 options.RegistryOptions, arg4 map[string]interface{}, arg5 []string, arg6 string, arg7 bool, arg8 string, arg9 string, arg10 string, arg11 bool, arg12 bool, arg13 string, arg14 bool) error {
	var arg5Copy []string
	if arg5 != nil {
		arg5Copy = make([]string, len(arg5))
		copy(arg5Copy, arg5)
	}
	fake.signImageInternalMutex.Lock()
	ret, specificReturn := fake.signImageInternalReturnsOnCall[len(fake.signImageInternalArgsForCall)]
	fake.signImageInternalArgsForCall = append(fake.signImageInternalArgsForCall, struct {
		arg1  options.RootOptions
		arg2  options.KeyOpts
		arg3  options.RegistryOptions
		arg4  map[string]interface{}
		arg5  []string
		arg6  string
		arg7  bool
		arg8  string
		arg9  string
		arg10 string
		arg11 bool
		arg12 bool
		arg13 string
		arg14 bool
	}{arg1, arg2, arg3, arg4, arg5Copy, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14})
	stub := fake.SignImageInternalStub
	fakeReturns := fake.signImageInternalReturns
	fake.recordInvocation("SignImageInternal", []interface{}{arg1, arg2, arg3, arg4, arg5Copy, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14})
	fake.signImageInternalMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeImpl) SignImageInternalCallCount() int {
	fake.signImageInternalMutex.RLock()
	defer fake.signImageInternalMutex.RUnlock()
	return len(fake.signImageInternalArgsForCall)
}

func (fake *FakeImpl) SignImageInternalCalls(stub func(options.RootOptions, options.KeyOpts, options.RegistryOptions, map[string]interface{}, []string, string, bool, string, string, string, bool, bool, string, bool) error) {
	fake.signImageInternalMutex.Lock()
	defer fake.signImageInternalMutex.Unlock()
	fake.SignImageInternalStub = stub
}

func (fake *FakeImpl) SignImageInternalArgsForCall(i int) (options.RootOptions, options.KeyOpts, options.RegistryOptions, map[string]interface{}, []string, string, bool, string, string, string, bool, bool, string, bool) {
	fake.signImageInternalMutex.RLock()
	defer fake.signImageInternalMutex.RUnlock()
	argsForCall := fake.signImageInternalArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4, argsForCall.arg5, argsForCall.arg6, argsForCall.arg7, argsForCall.arg8, argsForCall.arg9, argsForCall.arg10, argsForCall.arg11, argsForCall.arg12, argsForCall.arg13, argsForCall.arg14
}

func (fake *FakeImpl) SignImageInternalReturns(result1 error) {
	fake.signImageInternalMutex.Lock()
	defer fake.signImageInternalMutex.Unlock()
	fake.SignImageInternalStub = nil
	fake.signImageInternalReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeImpl) SignImageInternalReturnsOnCall(i int, result1 error) {
	fake.signImageInternalMutex.Lock()
	defer fake.signImageInternalMutex.Unlock()
	fake.SignImageInternalStub = nil
	if fake.signImageInternalReturnsOnCall == nil {
		fake.signImageInternalReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.signImageInternalReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeImpl) TokenFromProviders(arg1 context.Context, arg2 *logrus.Logger) (string, error) {
	fake.tokenFromProvidersMutex.Lock()
	ret, specificReturn := fake.tokenFromProvidersReturnsOnCall[len(fake.tokenFromProvidersArgsForCall)]
	fake.tokenFromProvidersArgsForCall = append(fake.tokenFromProvidersArgsForCall, struct {
		arg1 context.Context
		arg2 *logrus.Logger
	}{arg1, arg2})
	stub := fake.TokenFromProvidersStub
	fakeReturns := fake.tokenFromProvidersReturns
	fake.recordInvocation("TokenFromProviders", []interface{}{arg1, arg2})
	fake.tokenFromProvidersMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeImpl) TokenFromProvidersCallCount() int {
	fake.tokenFromProvidersMutex.RLock()
	defer fake.tokenFromProvidersMutex.RUnlock()
	return len(fake.tokenFromProvidersArgsForCall)
}

func (fake *FakeImpl) TokenFromProvidersCalls(stub func(context.Context, *logrus.Logger) (string, error)) {
	fake.tokenFromProvidersMutex.Lock()
	defer fake.tokenFromProvidersMutex.Unlock()
	fake.TokenFromProvidersStub = stub
}

func (fake *FakeImpl) TokenFromProvidersArgsForCall(i int) (context.Context, *logrus.Logger) {
	fake.tokenFromProvidersMutex.RLock()
	defer fake.tokenFromProvidersMutex.RUnlock()
	argsForCall := fake.tokenFromProvidersArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeImpl) TokenFromProvidersReturns(result1 string, result2 error) {
	fake.tokenFromProvidersMutex.Lock()
	defer fake.tokenFromProvidersMutex.Unlock()
	fake.TokenFromProvidersStub = nil
	fake.tokenFromProvidersReturns = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeImpl) TokenFromProvidersReturnsOnCall(i int, result1 string, result2 error) {
	fake.tokenFromProvidersMutex.Lock()
	defer fake.tokenFromProvidersMutex.Unlock()
	fake.TokenFromProvidersStub = nil
	if fake.tokenFromProvidersReturnsOnCall == nil {
		fake.tokenFromProvidersReturnsOnCall = make(map[int]struct {
			result1 string
			result2 error
		})
	}
	fake.tokenFromProvidersReturnsOnCall[i] = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeImpl) VerifyFileInternal(arg1 context.Context, arg2 options.KeyOpts, arg3 string, arg4 string, arg5 string) error {
	fake.verifyFileInternalMutex.Lock()
	ret, specificReturn := fake.verifyFileInternalReturnsOnCall[len(fake.verifyFileInternalArgsForCall)]
	fake.verifyFileInternalArgsForCall = append(fake.verifyFileInternalArgsForCall, struct {
		arg1 context.Context
		arg2 options.KeyOpts
		arg3 string
		arg4 string
		arg5 string
	}{arg1, arg2, arg3, arg4, arg5})
	stub := fake.VerifyFileInternalStub
	fakeReturns := fake.verifyFileInternalReturns
	fake.recordInvocation("VerifyFileInternal", []interface{}{arg1, arg2, arg3, arg4, arg5})
	fake.verifyFileInternalMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4, arg5)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeImpl) VerifyFileInternalCallCount() int {
	fake.verifyFileInternalMutex.RLock()
	defer fake.verifyFileInternalMutex.RUnlock()
	return len(fake.verifyFileInternalArgsForCall)
}

func (fake *FakeImpl) VerifyFileInternalCalls(stub func(context.Context, options.KeyOpts, string, string, string) error) {
	fake.verifyFileInternalMutex.Lock()
	defer fake.verifyFileInternalMutex.Unlock()
	fake.VerifyFileInternalStub = stub
}

func (fake *FakeImpl) VerifyFileInternalArgsForCall(i int) (context.Context, options.KeyOpts, string, string, string) {
	fake.verifyFileInternalMutex.RLock()
	defer fake.verifyFileInternalMutex.RUnlock()
	argsForCall := fake.verifyFileInternalArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4, argsForCall.arg5
}

func (fake *FakeImpl) VerifyFileInternalReturns(result1 error) {
	fake.verifyFileInternalMutex.Lock()
	defer fake.verifyFileInternalMutex.Unlock()
	fake.VerifyFileInternalStub = nil
	fake.verifyFileInternalReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeImpl) VerifyFileInternalReturnsOnCall(i int, result1 error) {
	fake.verifyFileInternalMutex.Lock()
	defer fake.verifyFileInternalMutex.Unlock()
	fake.VerifyFileInternalStub = nil
	if fake.verifyFileInternalReturnsOnCall == nil {
		fake.verifyFileInternalReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.verifyFileInternalReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeImpl) VerifyImageInternal(arg1 context.Context, arg2 string, arg3 []string) (*sign.SignedObject, error) {
	var arg3Copy []string
	if arg3 != nil {
		arg3Copy = make([]string, len(arg3))
		copy(arg3Copy, arg3)
	}
	fake.verifyImageInternalMutex.Lock()
	ret, specificReturn := fake.verifyImageInternalReturnsOnCall[len(fake.verifyImageInternalArgsForCall)]
	fake.verifyImageInternalArgsForCall = append(fake.verifyImageInternalArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 []string
	}{arg1, arg2, arg3Copy})
	stub := fake.VerifyImageInternalStub
	fakeReturns := fake.verifyImageInternalReturns
	fake.recordInvocation("VerifyImageInternal", []interface{}{arg1, arg2, arg3Copy})
	fake.verifyImageInternalMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeImpl) VerifyImageInternalCallCount() int {
	fake.verifyImageInternalMutex.RLock()
	defer fake.verifyImageInternalMutex.RUnlock()
	return len(fake.verifyImageInternalArgsForCall)
}

func (fake *FakeImpl) VerifyImageInternalCalls(stub func(context.Context, string, []string) (*sign.SignedObject, error)) {
	fake.verifyImageInternalMutex.Lock()
	defer fake.verifyImageInternalMutex.Unlock()
	fake.VerifyImageInternalStub = stub
}

func (fake *FakeImpl) VerifyImageInternalArgsForCall(i int) (context.Context, string, []string) {
	fake.verifyImageInternalMutex.RLock()
	defer fake.verifyImageInternalMutex.RUnlock()
	argsForCall := fake.verifyImageInternalArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeImpl) VerifyImageInternalReturns(result1 *sign.SignedObject, result2 error) {
	fake.verifyImageInternalMutex.Lock()
	defer fake.verifyImageInternalMutex.Unlock()
	fake.VerifyImageInternalStub = nil
	fake.verifyImageInternalReturns = struct {
		result1 *sign.SignedObject
		result2 error
	}{result1, result2}
}

func (fake *FakeImpl) VerifyImageInternalReturnsOnCall(i int, result1 *sign.SignedObject, result2 error) {
	fake.verifyImageInternalMutex.Lock()
	defer fake.verifyImageInternalMutex.Unlock()
	fake.VerifyImageInternalStub = nil
	if fake.verifyImageInternalReturnsOnCall == nil {
		fake.verifyImageInternalReturnsOnCall = make(map[int]struct {
			result1 *sign.SignedObject
			result2 error
		})
	}
	fake.verifyImageInternalReturnsOnCall[i] = struct {
		result1 *sign.SignedObject
		result2 error
	}{result1, result2}
}

func (fake *FakeImpl) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.digestMutex.RLock()
	defer fake.digestMutex.RUnlock()
	fake.envDefaultMutex.RLock()
	defer fake.envDefaultMutex.RUnlock()
	fake.fileExistsMutex.RLock()
	defer fake.fileExistsMutex.RUnlock()
	fake.findTLogEntriesByPayloadMutex.RLock()
	defer fake.findTLogEntriesByPayloadMutex.RUnlock()
	fake.imagesSignedMutex.RLock()
	defer fake.imagesSignedMutex.RUnlock()
	fake.newRekorClientMutex.RLock()
	defer fake.newRekorClientMutex.RUnlock()
	fake.newWithContextMutex.RLock()
	defer fake.newWithContextMutex.RUnlock()
	fake.parseReferenceMutex.RLock()
	defer fake.parseReferenceMutex.RUnlock()
	fake.payloadBytesMutex.RLock()
	defer fake.payloadBytesMutex.RUnlock()
	fake.setenvMutex.RLock()
	defer fake.setenvMutex.RUnlock()
	fake.signFileInternalMutex.RLock()
	defer fake.signFileInternalMutex.RUnlock()
	fake.signImageInternalMutex.RLock()
	defer fake.signImageInternalMutex.RUnlock()
	fake.tokenFromProvidersMutex.RLock()
	defer fake.tokenFromProvidersMutex.RUnlock()
	fake.verifyFileInternalMutex.RLock()
	defer fake.verifyFileInternalMutex.RUnlock()
	fake.verifyImageInternalMutex.RLock()
	defer fake.verifyImageInternalMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeImpl) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}
